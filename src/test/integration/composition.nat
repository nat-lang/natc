import test/prelude

// constants.

const Agnetha, Bjorn, Benny, Carlos, Paco, Frida, Ariel;

// types.

dom e = {Agnetha, Bjorn, Benny, Carlos, Paco, Frida, Ariel};
dom t = {true, false};

bool = t;

// common nouns.

let Singer = {};
let singer: e -> t = x => x in Singer;

let Millionaire = {};
let millionaire: e -> t = x => x in Millionaire;

let Norwegian = {};
let norwegian: e -> t = x => x in Norwegian;

// intransitive verbs.

let Smile = {};
let smiled: e -> t = x => x in Smile;

// transitive verbs.

let Love = {(Agnetha, Agnetha)};
let loves: e -> e -> t = x y => (x,y) in Love;

let Shave = {};
let shaves: e -> e -> t = x y => (x,y) in Shave;

// ditransitive verbs.

let Introduce = {};
let introduced: e -> e -> e -> t = x y z => (x,y,z) in Introduce;

// prepositions.

let to : e -> (e -> e -> t) -> e -> t
       = x p y => p(x)(y);

let self1 : (e -> e -> t) -> e -> t
          = p x => p(x)(x);

let self2 : (e -> e -> e -> t) -> e -> e -> t
          = p x y => p(x)(y)(y);

let self3 : (e -> e -> e -> t) -> e -> e -> t
          = p x y => p(x)(y)(x);

let With = {};
let with: e -> e -> t = x y => (x,y) in With;

let of: e -> e = x => x;

// 1-place adjectives.

let Kind = {};
let kind: e -> t = x => x in Kind;

let Snore = {};
let snores: e -> t = x => x in Snore;

// 2-place adjectives.

let Proud = {};
let proud: e -> e -> t = x y => (x,y) in Proud;

let Hug = {};
let hugged: e -> e -> t = x y => (x,y) in Hug;

let Afraid = {};
let afraid: e -> e -> t = x y => (x,y) in Afraid;

// copula.

let is': (e -> t) -> e -> t = p => p;

// negation.
// quantifiers.

let everybody: (e -> t) -> t = p => e.each(p);
let somebody: (e -> t) -> t = p => e.some(p);
let nobody: (e -> t) -> t = p => !e.some(p);

// determiners.

let a: (e -> t) -> e -> t = p => p;
let some: (e -> t) -> (e -> t) -> t = p q => e.some(x => p(x) and q(x));
let no: (e -> t) -> (e -> t) -> t = p q => !e.some(x => p(x) and q(x));
let every: (e -> t) -> (e -> t) -> t = p q => e.each(x => !p(x) or q(x));

// composition rules.

let QuantificationalObject
  = (r: (e -> e -> t), q: (e -> t) -> t) => (x => q(z => r(z)(x)))
  | (q: (e -> t) -> t, r: (e -> e -> t)) => (x => q(z => r(z)(x)));

grammar.addRules(QuantificationalObject);

// examples.

ex [Agnetha smiled];
ex [Agnetha [loves Bjorn]];
ex [Benny [[introduced Agnetha] [to Bjorn]]];
ex [Carlos [self1 shaves]];
ex [Carlos [[self2 introduced] Paco]];
ex [Carlos [[self3 introduced] Paco]];
ex [Bjorn [is' kind]];
ex [Frida [is' [with Benny]]];
ex [Benny [is' [proud [of Frida]]]];
ex [Agnetha [is' [a singer]]];
ex [Frida [is' [a [norwegian millionaire]]]];
ex [[every singer] smiled];
ex [[a singer] smiled];
ex [everybody snores];
ex [somebody [hugged Ariel]];
ex [everybody [is' [afraid [of Ariel]]]];
ex [nobody [likes Ursula]];
ex [[some guy] [hugged Sebastian]];
ex [Sam [smokes [or' drinks]]];
ex [everybody [smokes [or' drinks]]];
ex [Agnetha [likes nobody]];
