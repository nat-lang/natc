
let _ASTClosureMock = klass => (*children) => {
  let mock = klass(nil,nil,[]);
  mock.children = children;
  return mock;
};

let ASTClosureMock = _ASTClosureMock(ASTClosure);
let ASTComprehensionMock = _ASTClosureMock(ASTComprehension);
let ASTBlockMock = (*children) => ASTBlock(nil, ..children);
let ASTInternalUpvalueMock = name => ASTInternalUpvalue(nil,nil,nil,name);
let ASTExternalUpvalueMock = name => ASTExternalUpvalue(nil,nil,nil,name);

// constant function to literal.

let f <- (a) => 1;

assert(vType(f.function) == OFunction);
assert(vType(f.function.signature) == OFunction);
assert(f.upvalues is Map);

assert(f.signature() is ASTSignature);
assert(len(f.signature().children) == 1);

let p = f.signature().children[0];

assert(p is ASTParameter);
assert(p.id == 1);
assert(p.value == nil);
assert(p.type == undefined);

// explicit and implicit returns.
assert(len(f.children) == 2);

// explicit.
assert(f[0] is ASTReturn);
assert(f[0][0] is ASTLiteral);
assert(f[0][0].value == 1);

// implicit.
assert(f[1] is ASTImplicitReturn);
assert(f[1][0] is ASTLiteral);
assert(f[1][0].value == nil);

// constant function to global.
let f <- (a) => c;

// explicit and implicit returns.
assert(len(f.children) == 2);

// explicit.
assert(f[0] is ASTReturn);
assert(f[0][0] is ASTGlobal);
assert(f[0][0].id == "c");

// implicit.
assert(f[1] is ASTImplicitReturn);
assert(f[1][0] is ASTLiteral);
assert(f[1][0].value == nil);

// constant function to local.
let f <- (a) => a;

// explicit and implicit returns.
assert(len(f.children) == 2);

// explicit.
assert(f[0] is ASTReturn);
assert(f[0][0] is ASTLocal);
assert(f[0][0].id == 1);

// implicit.
assert(f[1] is ASTImplicitReturn);
assert(f[1][0] is ASTLiteral);
assert(f[1][0].value == nil);

// function to infix.

let f <- (a) => a + 1;

let r = f[0];

assert(r is ASTReturn);
assert(r[0] is ASTAppInfix);
assert(r[0][0].id == "+");

let f <- (a) => +(a, 1);

let r = f[0];
assert(r is ASTReturn);
assert(r[0] is ASTApp);
assert(r[0][0].id == "+");

// function to postfix.

let f <- (a) => [1,2,3];

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTApp);
assert(f[0][0][0].id == "Sequence");
assert(f[0][0][1].resolve() == [1,2,3]);

// function to function.

let f <- (g) => (x) => 1;

assert(f[0][0] is ASTClosure);

assert(f[0][0][0][0] is ASTLiteral);

let f <- g x => 1;

assert(f[0][0] is ASTClosure);
assert(f[0][0][0][0] is ASTLiteral);

let f <- (g) => (x) => g(x);

assert(f[0][0] is ASTClosure);
assert(f[0][0][0][0] is ASTApp);

let f <- (f, g) => (x) => f(g(x));

assert(f[0][0] is ASTClosure);
assert(f[0][0][0][0] is ASTApp);

// local assignment.

let f <- (g) => {
  let a = 1;
  return a;
};

assert(len(f.children) == 3);

assert(f[0] is ASTLocalValueAssignment);
assert(f[0][1] is ASTLiteral);
assert(f[1] is ASTReturn);
assert(f[2] is ASTImplicitReturn);

let f <- (g) => {
  let k = (x) => 1;
  k(1);
};

assert(len(f.children) == 3);

assert(f[0] is ASTLocalValueAssignment);
assert(f[0][1] is ASTClosure);
assert(f[1] is ASTExprStatement);
assert(f[2] is ASTImplicitReturn);

let f <- (g) => {
  let k = (x) => 1;
  let j = 1;
  k(j);
};

assert(len(f.children) == 4);

// k.
assert(f[0] is ASTLocalValueAssignment);
assert(f[0][1] is ASTClosure);

// j.
assert(f[1] is ASTLocalValueAssignment);
assert(f[1][1] is ASTLiteral);

// k(j).
assert(f[2] is ASTExprStatement);
assert(f[3] is ASTImplicitReturn);

let f <- () => {
  let a = 1;
  a;
  a = 2;
  a;
};

assert(f[0] is ASTLocalValueAssignment);
assert(f[0][0] is ASTLocal);
assert(f[0][1] is ASTLiteral);

assert(f[1] is ASTExprStatement);
assert(f[1][0] is ASTLocal);

assert(f[2] is ASTLocalValueAssignment);
assert(f[2][0] is ASTLocal);
assert(f[2][1] is ASTLiteral);

assert(f[3] is ASTExprStatement);
assert(f[3][0] is ASTLiteral);
assert(f[3][0].resolve() == 2);

assert(f[4] is ASTExprStatement);
assert(f[4][0] is ASTLocal);

// negation.

let f <- (a) => !a;

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTNegation);
assert(f[0][0][0] is ASTLocal);

// equality.

let f <- (x, y) => x == y;

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTEquality);
assert(f[0][0][0] is ASTLocal);
assert(f[0][0][1] is ASTLocal);

let f <- (x, y) => x != y;

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTNegation);

assert(f[0][0][0] is ASTEquality);
assert(f[0][0][0][0] is ASTLocal);
assert(f[0][0][0][1] is ASTLocal);

// jumpy operators.

// short circuited booleans.

// and.

let f <- () => true && false;

assert(f is ASTClosure);
assert(f.children == [
  ASTConditional(
    ASTLiteral(true),
    ASTBlockMock(
      ASTReturn(
        ASTLiteral(false)
      )
    )
  ),
  ASTReturn(
    ASTLiteral(true)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

// or.

let f <- () => true || false;

assert(f is ASTClosure);
assert(f.children == [
  ASTConditional(
    ASTLiteral(true),
    ASTBlockMock(
      ASTReturn(
        ASTLiteral(true)
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTReturn(
    ASTLiteral(false)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

// conditionals.

// if.

let f <- () => {
  if (true) 1;
  2;
};

assert(f is ASTClosure);
assert(f.children == [
  ASTConditional(
    ASTLiteral(true),
    ASTBlockMock(
      ASTExprStatement(
        ASTLiteral(1)
      ),
      ASTExprStatement(
        ASTLiteral(2)
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTExprStatement(
    ASTLiteral(2)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

// if if.

let f <- () => {
  if (true) if (false) 1;
};

assert(f == ASTClosureMock(
  ASTConditional(
    ASTLiteral(true),
    ASTBlockMock(
      ASTConditional(
        ASTLiteral(false),
        ASTBlockMock(
          ASTExprStatement(
            ASTLiteral(1)
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// if else.

let f <- () => {
  if (true) 1;
  else 2;
};

assert(f is ASTClosure);
assert(f.children == [
  ASTConditional(
    ASTLiteral(true),
    ASTBlockMock(
      ASTExprStatement(
        ASTLiteral(1)
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTExprStatement(
    ASTLiteral(2)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

let f <- () => {
  if (true) 1;
  else 2;
  3;
};

assert(f is ASTClosure);
assert(f.children == [
  ASTConditional(
    ASTLiteral(true),
    ASTBlockMock(
      ASTExprStatement(
        ASTLiteral(1)
      ),
      ASTExprStatement(
        ASTLiteral(3)
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTExprStatement(
    ASTLiteral(2)
  ),
  ASTExprStatement(
    ASTLiteral(3)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

// iteration.

let f <- () => {
  for (x in [1,2,3]) x;
};

assert(f == ASTClosureMock(
  ASTIterate(
    ASTLocal(1, "x"),
    ASTApp(
      ASTGlobal("iter"),
      ASTArgumentSequence(
        ASTApp(
          ASTGlobal("Sequence"),
          ASTArgumentSequence(
            ASTLiteral(1),
            ASTLiteral(2),
            ASTLiteral(3)
          )
        )
      )
    ),
    ASTBlockMock(
      ASTExprStatement(
        ASTLocal(1, "x")
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// nested iteration.

let f <- () => {
  for (x in [[1,2],[3,4]]) for (y in x) y;
};

assert(f == ASTClosureMock(
  ASTIterate(
    ASTLocal(1, "x"),
    ASTApp(
      ASTGlobal("iter"),
      ASTArgumentSequence(
        ASTApp(
          ASTGlobal("Sequence"),
          ASTArgumentSequence(
            ASTApp(
              ASTGlobal(Sequence),
              ASTArgumentSequence(
                ASTLiteral(1),
                ASTLiteral(2)
              )
            ),
            ASTApp(
              ASTGlobal(Sequence),
              ASTArgumentSequence(
                ASTLiteral(3),
                ASTLiteral(4)
              )
            )
          )
        )
      )
    ),
    ASTBlockMock(
      ASTIterate(
        ASTLocal(3, "y"),
        ASTApp(
          ASTGlobal("iter"),
          ASTArgumentSequence(
            ASTLocal(1, "x")
          )
        ),
        ASTBlockMock(
          ASTExprStatement(
            ASTLocal(3, "y")
          )
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// iteration with jumps.

let f <- () => {
  for (x in [1,2,3]) x || !x;
};

assert(f == ASTClosureMock(
  ASTIterate(
    ASTLocal(1, "x"),
    ASTApp(
      ASTGlobal("iter"),
      ASTArgumentSequence(
        ASTApp(
          ASTGlobal("Sequence"),
          ASTArgumentSequence(
            ASTLiteral(1),
            ASTLiteral(2),
            ASTLiteral(3)
          )
        )
      )
    ),
    ASTBlockMock(
      ASTConditional(
        ASTLocal(1, "x"),
        ASTBlockMock(
          ASTExprStatement(
            ASTLocal(1, "x")
          )
        )
      ),
      ASTExprStatement(
        ASTNegation(
          ASTLocal(1, "x")
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => {
  for (x in [1,2,3]) x && !x;
};

assert(f == ASTClosureMock(
  ASTIterate(
    ASTLocal(1, "x"),
    ASTApp(
      ASTGlobal("iter"),
      ASTArgumentSequence(
        ASTApp(
          ASTGlobal("Sequence"),
          ASTArgumentSequence(
            ASTLiteral(1),
            ASTLiteral(2),
            ASTLiteral(3)
          )
        )
      )
    ),
    ASTBlockMock(
      ASTConditional(
        ASTLocal(1, "x"),
        ASTBlockMock(
          ASTExprStatement(
            ASTNegation(
              ASTLocal(1, "x")
            )
          )
        )
      ),
      ASTExprStatement(
        ASTLocal(1, "x")
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => {
  for (x in [1,2,3]) {
    if (x) x;
  }
};

assert(f == ASTClosureMock(
  ASTIterate(
    ASTLocal(1, "x"),
    ASTApp(
      ASTGlobal("iter"),
      ASTArgumentSequence(
        ASTApp(
          ASTGlobal("Sequence"),
          ASTArgumentSequence(
            ASTLiteral(1),
            ASTLiteral(2),
            ASTLiteral(3)
          )
        )
      )
    ),
    ASTBlockMock(
      ASTConditional(
        ASTLocal(1, "x"),
        ASTBlockMock(
          ASTExprStatement(
            ASTLocal(1, "x")
          )
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => {
  for (x in [1,2,3]) {
    if (x) x;
    else if (!x) !x;
    else false;
  }
};

assert(f == ASTClosureMock(
  ASTIterate(
    ASTLocal(1, "x"),
    ASTApp(
      ASTGlobal("iter"),
      ASTArgumentSequence(
        ASTApp(
          ASTGlobal("Sequence"),
          ASTArgumentSequence(
            ASTLiteral(1),
            ASTLiteral(2),
            ASTLiteral(3)
          )
        )
      )
    ),
    ASTBlockMock(
      ASTConditional(
        ASTLocal(1, "x"),
        ASTBlockMock(
          ASTExprStatement(
            ASTLocal(1, "x")
          )
        )
      ),
      ASTConditional(
        ASTNegation(
          ASTLocal(1, "x")
        ),
        ASTBlockMock(
          ASTExprStatement(
            ASTNegation(
              ASTLocal(1, "x")
            )
          )
        )
      ),
      ASTExprStatement(
        ASTLiteral(false)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// comprehensions.

let f <- () => ({ 1 | true });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionPred(
        ASTLiteral(true),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTLiteral(1)
              )
            )
          ),
          ASTReturn(
            ASTLocal(1, "#comprehension-instance")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ({ 1 | x in [1,2] });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionIter(
        ASTLocal(2, "x"),
        ASTApp(
          ASTGlobal("iter"),
          ASTArgumentSequence(
            ASTApp(
              ASTGlobal("Sequence"),
              ASTArgumentSequence(
                ASTLiteral(1),
                ASTLiteral(2)
              )
            )
          )
        ),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTLiteral(1)
              )
            )
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ({ x | x in [1,2] });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionIter(
        ASTLocal(2, "x"),
        ASTApp(
          ASTGlobal("iter"),
          ASTArgumentSequence(
            ASTApp(
              ASTGlobal("Sequence"),
              ASTArgumentSequence(
                ASTLiteral(1),
                ASTLiteral(2)
              )
            )
          )
        ),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTLocal(2, "x")
              )
            )
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ({ x | true, x in [1,2] });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionPred(
        ASTLiteral(true),
        ASTBlockMock(
          ASTComprehensionIter(
            ASTLocal(2, "x"),
            ASTApp(
              ASTGlobal("iter"),
              ASTArgumentSequence(
                ASTApp(
                  ASTGlobal("Sequence"),
                  ASTArgumentSequence(
                    ASTLiteral(1),
                    ASTLiteral(2)
                  )
                )
              )
            ),
            ASTBlockMock(
              ASTComprehensionBody(
                ASTApp(
                  ASTPropertyAccess(
                    ASTLocal(1, "#comprehension-instance"),
                    ASTLiteral("add")
                  ),
                  ASTArgumentSequence(
                    ASTLocal(2, "x")
                  )
                )
              )
            )
          ),
          ASTReturn(
            ASTLocal(1, "#comprehension-instance")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ({ x | x in [1,2], true });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionIter(
        ASTLocal(2, "x"),
        ASTApp(
          ASTGlobal("iter"),
          ASTArgumentSequence(
            ASTApp(
              ASTGlobal("Sequence"),
              ASTArgumentSequence(
                ASTLiteral(1),
                ASTLiteral(2)
              )
            )
          )
        ),
        ASTBlockMock(
          ASTComprehensionPred(
            ASTLiteral(true),
            ASTBlockMock(
              ASTComprehensionBody(
                ASTApp(
                  ASTPropertyAccess(
                    ASTLocal(1, "#comprehension-instance"),
                    ASTLiteral("add")
                  ),
                  ASTArgumentSequence(
                    ASTLocal(2, "x")
                  )
                )
              )
            )
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ({ x | true, x in [1,2], false });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionPred(
        ASTLiteral(true),
        ASTBlockMock(
          ASTComprehensionIter(
            ASTLocal(2, "x"),
            ASTApp(
              ASTGlobal("iter"),
              ASTArgumentSequence(
                ASTApp(
                  ASTGlobal("Sequence"),
                  ASTArgumentSequence(
                    ASTLiteral(1),
                    ASTLiteral(2)
                  )
                )
              )
            ),
            ASTBlockMock(
              ASTComprehensionPred(
                ASTLiteral(false),
                ASTBlockMock(
                  ASTComprehensionBody(
                    ASTApp(
                      ASTPropertyAccess(
                        ASTLocal(1, "#comprehension-instance"),
                        ASTLiteral("add")
                      ),
                      ASTArgumentSequence(
                        ASTLocal(2, "x")
                      )
                    )
                  )
                )
              )
            )
          ),
          ASTReturn(
            ASTLocal(1, "#comprehension-instance")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// nested comprehensions.

let f <- () => ({ x | x in { x | x in z}});

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionIter(
        ASTLocal(2, "x"),
        ASTApp(
          ASTGlobal("iter"),
          ASTArgumentSequence(
            ASTComprehensionMock(
              ASTLocalValueAssignment(
                ASTLocal(2, "#comprehension-instance"),
                ASTApp(
                  ASTGlobal("Set"),
                  ASTArgumentSequence()
                )
              ),
              ASTComprehensionIter(
                ASTLocal(2, "x"),
                ASTApp(
                  ASTGlobal("iter"),
                  ASTArgumentSequence(
                    ASTGlobal("z")
                  )
                ),
                ASTBlockMock(
                  ASTComprehensionBody(
                    ASTApp(
                      ASTPropertyAccess(
                        ASTLocal(1, "#comprehension-instance"),
                        ASTLiteral("add")
                      ),
                      ASTArgumentSequence(
                        ASTLocal(2, "x")
                      )
                    )
                  )
                )
              ),
              ASTReturn(
                ASTLocal(1, "#comprehension-instance")
              ),
              ASTImplicitReturn(
                ASTLiteral(nil)
              )
            )
          )
        ),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTLocal(2, "x")
              )
            )
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ({{ y | y in x} | x in z});

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionIter(
        ASTLocal(2, "x"),
        ASTApp(
          ASTGlobal("iter"),
          ASTArgumentSequence(
            ASTGlobal("z")
          )
        ),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTComprehensionMock(
                  ASTLocalValueAssignment(
                    ASTLocal(1, "#comprehension-instance"),
                    ASTApp(
                      ASTGlobal("Set"),
                      ASTArgumentSequence()
                    )
                  ),
                  ASTComprehensionIter(
                    ASTLocal(2, "y"),
                    ASTApp(
                      ASTGlobal("iter"),
                      ASTArgumentSequence(
                        ASTInternalUpvalueMock("x")
                      )
                    ),
                    ASTBlockMock(
                      ASTComprehensionBody(
                        ASTApp(
                          ASTPropertyAccess(
                            ASTLocal(1, "#comprehension-instance"),
                            ASTLiteral("add")
                          ),
                          ASTArgumentSequence(
                            ASTLocal(2, "y")
                          )
                        )
                      )
                    )
                  ),
                  ASTReturn(
                    ASTLocal(1, "#comprehension-instance")
                  ),
                  ASTImplicitReturn(
                    ASTLiteral(nil)
                  )
                )
              )
            )
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// iteration and jump in condition.

let f <- () => ({ 1 | (() => { for (x in y) if (z) k; })() });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionPred(
        ASTApp(
          ASTClosureMock(
            ASTIterate(
              ASTLocal(1, "x"),
              ASTApp(
                ASTGlobal("iter"),
                ASTArgumentSequence(
                  ASTGlobal("y")
                )
              ),
              ASTBlockMock(
                ASTConditional(
                  ASTGlobal("z"),
                  ASTBlockMock(
                    ASTExprStatement(
                      ASTGlobal("k")
                    )
                  )
                )
              )
            ),
            ASTImplicitReturn(
              ASTLiteral(nil)
            )
          ),
          ASTArgumentSequence()
        ),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTLiteral(1)
              )
            )
          ),
          ASTReturn(
            ASTLocal(1, "#comprehension-instance")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// iteration and jump in body.

let f <- () => ({ (() => { for (x in y) if (z) k; })() | true });

assert(f == ASTClosureMock(
  ASTReturn(
    ASTComprehensionMock(
      ASTLocalValueAssignment(
        ASTLocal(1, "#comprehension-instance"),
        ASTApp(
          ASTGlobal("Set"),
          ASTArgumentSequence()
        )
      ),
      ASTComprehensionPred(
        ASTLiteral(true),
        ASTBlockMock(
          ASTComprehensionBody(
            ASTApp(
              ASTPropertyAccess(
                ASTLocal(1, "#comprehension-instance"),
                ASTLiteral("add")
              ),
              ASTArgumentSequence(
                ASTApp(
                  ASTClosureMock(
                    ASTIterate(
                      ASTLocal(1, "x"),
                      ASTApp(
                        ASTGlobal("iter"),
                        ASTArgumentSequence(
                          ASTGlobal("y")
                        )
                      ),
                      ASTBlockMock(
                        ASTConditional(
                          ASTGlobal("z"),
                          ASTBlockMock(
                            ASTExprStatement(
                              ASTGlobal("k")
                            )
                          )
                        )
                      )
                    ),
                    ASTImplicitReturn(
                      ASTLiteral(nil)
                    )
                  ),
                  ASTArgumentSequence()
                )
              )
            )
          ),
          ASTReturn(
            ASTLocal(1, "#comprehension-instance")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTReturn(
        ASTLocal(1, "#comprehension-instance")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// property access.

let obj = Object();
obj.one = 2;

let f <- () => obj.one;

let r = f[0][0];

assert(r is ASTPropertyAccess);
assert(r[0] is ASTGlobal);
assert(r[0].id == "obj");
assert(r[0].resolve() == obj);
assert(r[1] is ASTLiteral);
assert(r[1].resolve() == "one");

// property assignment.

let f <- () => {
  let a;
  a.x = 1;
};

assert(f[0] is ASTLocalValueAssignment);
assert(f[0][1] is ASTLiteral);

assert(f[1] is ASTPropertyAssignment);

assert(f[1][0] is ASTLocal);
assert(f[1][1] is ASTLiteral);
assert(f[1][1].resolve() == "x");
assert(f[1][2] is ASTLiteral);
assert(f[1][2].resolve() == 1);

// membership.

let f <- () => 1 in [1,2];

let r = f[0][0];

assert(r is ASTMembership);
assert(r[0] is ASTLiteral);
assert(r[0].resolve() == 1);
assert(r[1] is ASTApp);
assert(r[1].resolve() == [1,2]);

// upvalues.

// upvalues identify with the locals they close over.

let f <- k x => k;

f.rename();

let k = f.signature().children[0];
let k_up = f[0][0][0][0];

assert(k_up is ASTInternalUpvalue);
assert(k_up.name == "k");
assert(k.uuid == k_up.uuid);

// 

let f <- k j x => +(k, j);

f.rename();

let k = f.signature().children[0];
let j = f[0][0].signature().children[0];

let app = f[0][0][0][0][0][0],
    args = app[1];

let k_up = args[0],
    j_up = args[1];

assert(k_up is ASTInternalUpvalue);
assert(k_up.name == "k");

assert(j_up is ASTInternalUpvalue);
assert(j_up.name == "j");

assert(k.uuid == k_up.uuid);
assert(j.uuid == j_up.uuid);

//

let f <- x y => {
  let z;
  return () => (x, y, z);
};

f.rename();

let x = f.signature().children[0];
let y = f[0][0].signature().children[0];
let z = f[0][0][0][0];

let r = f[0][0][1][0][0],
    app = r[0],
    args = app[1],
    x_up = args[0],
    y_up = args[1],
    z_up = args[2];

assert(x_up is ASTInternalUpvalue);
assert(x_up.name == "x");

assert(y_up is ASTInternalUpvalue);
assert(y_up.name == "y");

assert(z_up is ASTInternalUpvalue);
assert(z_up.name == "z");

assert(x.uuid == x_up.uuid);
assert(y.uuid == y_up.uuid);
assert(z.uuid == z_up.uuid);

//

let f <- (x,z) => {
  let y;
  
  let g = () => x + z;
  let h = () => x + y;
  let j = () => {
    let a;
    return () => x + y + a;
  };
};

f.rename();

let x = f.signature().children[0];
let z = f.signature().children[1];
let y = f[0][0];

let g = f[1][1];
let h = f[2][1];
let j = f[3][1];

let g_x_up = g[0][0][1][0];
let g_z_up = g[0][0][1][1];

assert(g_x_up is ASTInternalUpvalue);
assert(g_x_up.name == "x");

assert(g_z_up is ASTInternalUpvalue);
assert(g_z_up.name == "z");

assert(g_x_up.uuid == x.uuid);
assert(g_z_up.uuid == z.uuid);

let h_x_up = h[0][0][1][0];
let h_y_up = h[0][0][1][1];

assert(h_x_up is ASTInternalUpvalue);
assert(h_x_up.name == "x");

assert(h_y_up is ASTInternalUpvalue);
assert(h_y_up.name == "y");

assert(h_x_up.uuid == x.uuid);
assert(h_y_up.uuid == y.uuid);

let j_x_up = j[1][0][0][0][1][0][1][0];
let j_y_up = j[1][0][0][0][1][0][1][1];

assert(j_x_up is ASTInternalUpvalue);
assert(j_x_up.name == "x");

assert(j_y_up is ASTInternalUpvalue);
assert(j_y_up.name == "y");

assert(j_x_up.uuid == x.uuid);
assert(j_y_up.uuid == y.uuid);

let a = j[0][0];
let j_a_up = j[1][0][0][0][1][1];

assert(j_a_up is ASTInternalUpvalue);
assert(j_a_up.name == "a");
assert(j_a_up.uuid == a.uuid);

// upvalues to locals outside the scope of
// an ast resolve to their values.

let g = (x => {
  let f <- () => x;
  return (f, y => { x = y; });
})(1);

let f = g[0], set = g[1];
let x = f[0][0];

assert(x is ASTExternalUpvalue);
assert(x.name == "x");
assert(x.resolve() == 1);

set(2);
assert(x.resolve() == 2);

//

let m = x => x == 1;
let h = m k x => (k . m)(x);

let f <- h(m);

let k = f.signature().children[0];
let x = f[0][0].signature().children[0];

let r = f[0][0][0],
    app = r[0],
    composition = app[0],
    dot = composition[0],
    k_up = composition[1][0],
    m_up = composition[1][1];

assert(dot is ASTGlobal);
assert(k_up is ASTInternalUpvalue);
assert(k_up.name == "k");

assert(m_up is ASTExternalUpvalue);
assert(m_up.name == "m");

assert(dot.resolve() == compose);
assert(m_up.resolve() == m);

// upvalues in conditional branches.

let f <- up x => x && up;

assert(f is ASTClosure);

let g = f[0][0];

assert(g.children == [
  ASTConditional(
    ASTLocal(1, "x"),
    ASTBlockMock(
      ASTReturn(
        // dummy params: the values change run to run
        // and we're interested in the structure.
        ASTInternalUpvalue(undefined,undefined,undefined,"up")
      )
    )
  ),
  ASTReturn(
    ASTLocal(1, "x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

let f = (() => {
  let up = false;
  let g <- x => x && up;
  return g;
})();

assert(f is ASTClosure);

assert(f.children == [
  ASTConditional(
    ASTLocal(1, "x"),
    ASTBlockMock(
      ASTReturn(
        ASTExternalUpvalueMock("up")
      )
    )
  ),
  ASTReturn(
    ASTLocal(1, "x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
]);

// overloaded functions.

let f <- 1 => true | 2 => false;

assert(f is ASTOverload);
assert(vType(f.overload) == OOverload);
assert(f.overload.name == "f");
assert(f.count == 2);
assert(f[0] is ASTClosure);
assert(f[1] is ASTClosure);

let f <- () => {
  let g = 1 => true | 2 => false;
};

let g = f[0][1];

assert(g is ASTOverload);
assert(vType(g.overload) == OOverload);
assert(g.overload.name == "g");
assert(g.count == 2);
assert(g[0] is ASTClosure);
assert(g[1] is ASTClosure);

// classes.

// methods.

class A { f(a) => this; }

let a = A();
let f <- a.f;

assert(f is ASTMethod);

assert(f.klass == A);
assert(vType(f.method) == OBoundFunction);
assert(f.receiver == a);
assert(f[0] is ASTClosure);

assert(vType(f[0].function) == OFunction);
assert(vType(f[0].function.signature) == OFunction);
assert(f[0].upvalues is Map);
assert(f[0].signature() is ASTSignature);
assert(len(f[0].signature().children) == 1);

let p = f[0].signature().children[0];

assert(p is ASTParameter);
assert(p.id == 1);
assert(p.value == nil);
assert(p.type == undefined);

// membership in methods.

class A {
  f(x) => x in this.y;
}

let a = A();
let f <- a.f;

assert(f is ASTMethod);
assert(f[0] is ASTClosure);
assert(f[0][0] is ASTReturn);
assert(f[0][0][0] is ASTMembership);
assert(f[0][0][0][0] is ASTLocal);
assert(f[0][0][0][1] is ASTPropertyAccess);
assert(f[0][0][0][1][0] is ASTLocal);
assert(f[0][0][0][1][1] is ASTLiteral);

// type annotation.

let f <- () => {
  let f: 1 = () => 1;
};

assert(f[0] is ASTLocalValueAssignment);
assert(f[0][1] is ASTClosure);

assert(f[1] is ASTLocalTypeAssignment);
assert(f[1][1] is ASTLiteral);
assert(f[1][1].resolve() == 1);

let f <- () => {
  let k: num -> (num -> num) = (a: num -> num) => a(1);
};

// two type assignments for 'k':
// (0) for the let declaration,
// (1) for the signature.

let t0 = f[1];

assert(t0 is ASTLocalTypeAssignment);
assert(t0[1] is ASTApp);
assert(t0[1].resolve() == num -> (num -> num));

// the closure's signature lives on its node.

let k = f[0][1];

assert(k is ASTClosure);
assert(k.signature() is ASTSignature);

let a = k.signature().children[0];

assert(a is ASTParameter);
assert(a.type is TFunction);
assert(a.type.domain == num);
assert(a.type.range == num);

// implicitly abstract type variables in function signatures.

let f <- () => {
  let k = (a: w -> w) => a;
};

let k = f[0][1];

assert(k is ASTClosure);
assert(vType(k.function.signature) == OFunction);
assert(k.signature() is ASTSignature);
assert(len(k.signature().children) == 1);

let p = k.signature().children[0];

assert(p is ASTParameter);
assert(p.id == 1);
assert(p.value == nil);
assert(p.type is ->);

// quantification.

let f <- () => for _ (x in p) !x;

assert(f == ASTClosureMock(
  ASTReturn(
    ASTQuantification(
      ASTPropertyAccess(
        ASTGlobal("Quantification"),
        ASTLiteral("_")
      ),
      ASTGlobal("q"),
      ASTClosureMock(
        ASTReturn(
          ASTNegation(
            ASTLocal(1, "x")
          )
        ),
        ASTImplicitReturn(
          ASTLiteral(nil)
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => for _ (x in {1,2,3}) x not in {4,5,6};

assert(f == ASTClosureMock(
  ASTReturn(
    ASTQuantification(
      ASTPropertyAccess(
        ASTGlobal("Quantification"),
        ASTLiteral("_")
      ),
      ASTApp(
        ASTGlobal("Set"),
        ASTArgumentSequence(
          ASTLiteral(1),
          ASTLiteral(2),
          ASTLiteral(3)
        )
      ),
      ASTClosureMock(
        ASTReturn(
          ASTNegation(
            ASTMembership(
              ASTLocal(1, "x"),
              ASTApp(
                ASTGlobal("Set"),
                ASTArgumentSequence(
                  ASTLiteral(4),
                  ASTLiteral(5),
                  ASTLiteral(6)
                )
              )
            )
          )
        ),
        ASTImplicitReturn(
          ASTLiteral(nil)
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => for all (x in {1,2,3}) x not in {4,5,6};
let q = f[0][0];

assert(q.resolve());

assert(q.body is ASTClosure);
assert(vType(q.body.function.signature) == OFunction);
assert(q.body.sign() is ASTSignature);

let f <- () => for no (x in {1,2,3}) x in {1};
let q = f[0][0];

assert(!q.resolve());

assert(q.body is ASTClosure);
assert(vType(q.body.function.signature) == OFunction);
assert(q.body.sign() is ASTSignature);

let f <- () => for some (x in {1,2,3}) x == 1;
let q = f[0][0];

assert(q.resolve());

assert(q.body is ASTClosure);
assert(vType(q.body.function.signature) == OFunction);
assert(q.body.sign() is ASTSignature);

// modules.

let f <- () => {
  import test/integration/module/importable
};

assert(f == ASTClosureMock(
  ASTImport(nil),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

assert(f[0].module.x == 1);

let f <- () => {
  import test/integration/module/importable as importable
};

assert(f == ASTClosureMock(
  ASTImportAs(nil,nil),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

assert(f[0].module.x == nil);
assert(f[0].alias == ASTLiteral("importable"));

// unrolling resolves external upvalues that point to closures.

let f <- (() => {
  let x = x => x;
  return () => x;
})();

assert(f == ASTClosureMock(
  ASTReturn(
    ASTExternalUpvalueMock("x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f' = f.unroll();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTClosureMock(
      ASTReturn(
        ASTLocal(1, "x")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// unrolling unrolls resolved closures.

let f <- (() => {
  let y = y => 1;
  let x = () => y;
  return () => x;
})();

assert(f == ASTClosureMock(
  ASTReturn(
    ASTExternalUpvalueMock("x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f' = f.unroll();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTClosureMock(
      ASTReturn(
        ASTClosureMock(
          ASTReturn(
            ASTLiteral(1)
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// beta reduction.

// reduction for literals, locals, globals, and upvalues is identity.

let f <- () => 1;
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTLiteral(1)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- x => x;
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTLocal(1, "x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let x = 1;
let f <- () => x;
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTGlobal("x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// external.
let f <- (() => {
  let x = 1;
  return () => x;
})();
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTExternalUpvalueMock("x")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// internal.
let f <- x y => x;
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTClosureMock(
      ASTReturn(
        ASTInternalUpvalueMock("x")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// reduction of an application:
//  a) reduces arguments,
//  b) reduces applicand if it's an application itself,
//  c) performs substitution, and
//  d) reduces the reduct if any argument is a function.

// (c)
let f <- () => (x => x)(1);

assert(f == ASTClosureMock(
  ASTReturn(
    ASTApp(
      ASTClosureMock(
        ASTReturn(
          ASTLocal(1, "x")
        ),
        ASTImplicitReturn(
          ASTLiteral(nil)
        )
      ),
      ASTArgumentSequence(
        ASTLiteral(1)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

f.rename();
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTLiteral(1)
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// (b)

let f <- () => ((x => x)(y))(1);

assert(f == ASTClosureMock(
  ASTReturn(
    ASTApp(
      ASTApp(
        ASTClosureMock(
          ASTReturn(
            ASTLocal(1, "x")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        ),
        ASTArgumentSequence(
          ASTGlobal("y")
        )
      ),
      ASTArgumentSequence(
        ASTLiteral(1)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

f.rename();
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTApp(
      ASTGlobal("y"),
      ASTArgumentSequence(
        ASTLiteral(1)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// (a)

let f <- () => y((x => x)(1));

assert(f == ASTClosureMock(
  ASTReturn(
    ASTApp(
      ASTGlobal("y"),
      ASTArgumentSequence(
        ASTApp(
          ASTClosureMock(
            ASTReturn(
              ASTLocal(1, "x")
            ),
            ASTImplicitReturn(
              ASTLiteral(nil)
            )
          ),
          ASTArgumentSequence(
            ASTLiteral(1)
          )
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

f.rename();
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTApp(
      ASTGlobal("y"),
      ASTArgumentSequence(
        ASTLiteral(1)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// (d)

let f <- () => ((x => x(y)))(x => x);

assert(f == ASTClosureMock(
  ASTReturn(
    ASTApp(
      ASTClosureMock(
        ASTReturn(
          ASTApp(
            ASTLocal(1, "x"),
            ASTArgumentSequence(
              ASTGlobal("y")
            )
          )
        ),
        ASTImplicitReturn(
          ASTLiteral(nil)
        )
      ),
      ASTArgumentSequence(
        ASTClosureMock(
          ASTReturn(
            ASTLocal(1, "x")
          ),
          ASTImplicitReturn(
            ASTLiteral(nil)
          )
        )
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

f.rename();
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTGlobal("y")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

let f <- () => ((x => x(x)))(x => x);

f.rename();
let f' = f.betaReduce();

assert(f' == ASTClosureMock(
  ASTReturn(
    ASTClosureMock(
      ASTReturn(
        ASTLocal(1, "x")
      ),
      ASTImplicitReturn(
        ASTLiteral(nil)
      )
    )
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));

// exceptions.

let f <- () => { throw z; };

assert(f == ASTClosureMock(
  ASTThrow(
    ASTGlobal("z")
  ),
  ASTImplicitReturn(
    ASTLiteral(nil)
  )
));