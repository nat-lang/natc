
class TypedTree extends Tree {
  init(data, children, type: Type) => {
    super.init(data, children);
    this.type = type;
  }
  str() => {
    let s = "[";
    s = s + this.type.str();
    for (x in this.children)
      s = s + " " + x.str();
    s = s + "]";
    return s;
  }
}

class CompositionSystem {
  init(binaryRules, unaryRules, typeShifters) => {
    this.binaryRules = binaryRules;
    this.unaryRules = unaryRules;
    this.typeShifters = typeShifters;
  }

  addRule(rule) => {
    let add = (rule: (x,y) -> z) => this.binaryRules.add(rule)
            | (rule: x -> y) => this.typeShifters.add(rule)
            | (rule: SyntacticRule) => this.unaryRules.add(rule);

    add(rule);
  }

  // Map a Tree into a TypedTree.
  type(node: Tree) => {
    if (node.leaf())
      return TypedTree(node.data, [], TypeSystem.type(node.data));

    if (node.unary()) {
      let child = this.type(node[0]);
      return TypedTree(child.data, [child], child.type);
    }

    if (node.binary()) {
      let left = this.type(node[0]),
          right = this.type(node[1]);

      for (rule in this.binaryRules) {
        let data = rule(left.data, right.data);

        if (data != undefined)
          return TypedTree(data, [left, right], TypeSystem.type(data));
      }

      return TypedTree(node.data, [left, right], nil);
    }

    throw CompositionError("Nonbinary tree.");
  }

  interpret(node: Tree) => this.type(node).data;
  typecheck(node: Tree) => this.type(node).type != nil;
}