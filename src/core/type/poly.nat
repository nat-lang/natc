

class TAbstract extends Type {
  init(fn, arity) => {
    this.fn = fn;
    this.arity = arity;
  }

  instantiate(nameSupply) => {
    let tVars = [];
    for (let i = 0; i < this.arity; i = i + 1)
      tVars.push(nameSupply());
    return TypeSystem.typify(this.fn(..tVars));
  }

  generalize(type: TFunction) => {
    // instantiate any abstractions lower in the
    // type so that we're always first order.
    let normal = type.map(
      (x: TAbstract) => x.instantiate(typeVar) | x => x
    );
    let fvs = normal.fvs();
  
    // simulate the function with type substitution.
    return TAbstract((*args) => {
      let s = Substitution(..zip(fvs.toSeq(), args));
      return normal.apply(s);
    }, len(fvs));
  }

  fromFn(fn: OFunction) => TAbstract(fn, fn.arity);

  str() => {
    let tVars = [
      ["u", "v", "w", "x", "y", "z"][i] | i in range(0, this.arity)
    ];
    class PrettyTVar extends TVar { str() => this.id; }
    let type = TypeSystem.typify(this.fn(..[PrettyTVar(v) | v in tVars]));
    return "(" + join([v | v in tVars], ",") + ") => " + type.str();
  }
  pp() => { print this.str(); }
}

class PolyTypeState extends AdhocTypeState {
  constrain(node: ASTNode) => {
    let type = super.constrain(node);

    if (node is ASTClosure and type.hasFvs()) {
      return TAbstract.generalize(type);
    }

    return type;
  }

  unify(constraint: Constraint) => {
    let left = constraint.left,
        right = constraint.right;

    if (left is TAbstract and !(right is TVar))
      left = left.instantiate(typeVar);
    
    if (right is TAbstract and !(left is TVar))
      right = right.instantiate(typeVar);
    
    return super.unify(this.system.ConstraintClass(left, right));
  }

  // Calculate the type of [expr], inferring it if necessary.
  type(expr) => {
    let type = this.system.literalType(expr);
    if (type) return type;

    type = this.infer(expr);

    // instantiate abstract types if we have
    // annotations to incorporate.
    if (len(annotations(expr)) > 0 and type is TAbstract)
      type = type.instantiate(typeVar);

    return this.unifyAnnotations(expr, type);
  }
}

class PolyTypeSystem extends AdhocTypeSystem {
  typify(value) => {
    if (vType(value) == OFunction)
      return TAbstract.fromFn(value);

    return super.typify(value);
  }
}

PolyTypeSystem.TypeStateClass = PolyTypeState;
