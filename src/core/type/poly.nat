

class TAbstract extends Type {
  init(fn) => {
    this.fn = fn;
    this.arity = fn.arity;
  }

  instantiate(nameSupply) => {
    let tVars = [];
    for (let i = 0; i < this.arity; i = i + 1)
      tVars.push(nameSupply());
    return TypeSystem.typify(this.fn(..tVars));
  }

  str() => {
    let tVars = [
      ["u", "v", "w", "x", "y", "z"][i] | i in range(0, this.arity)
    ];
    class PrettyTVar extends TVar { str() => this.id; }
    let type = TypeSystem.typify(this.fn(..[PrettyTVar(v) | v in tVars]));
    return "(" + join([v | v in tVars], ",") + ") => " + type.str();
  }
  pp() => { print this.str(); }
}

class TGeneralization extends TAbstract {
  init(concrete) => {
    this.concrete = concrete;
    this.arity = len(concrete.fvs());
  }

  fvs() => this.concrete.fvs();

  fn(*args) => {
    // simulate the function with type substitution.
    let sub = Substitution(..zip(this.fvs().toSeq(), args));
    return this.concrete.apply(sub);
  }
}

class PolyTypeState extends AdhocTypeState {
  constrain(node: ASTNode) => {
    if (node is ASTClosure) {
      let tParams = this.constrainFnParams(node),
          tReturns = this.constrainFnReturns(node);

      tParams = tParams.apply(this.solution);
      tReturns = tReturns.apply(this.solution);

      if (tReturns is TGeneralization)
        tReturns = tReturns.concrete;

      let type = tParams -> tReturns;

      if (type.hasFvs())
        return TGeneralization(type);

      return type;
    }

    return super.constrain(node);
  }

  unify(constraint: Constraint) => {
    let left = constraint.left,
        right = constraint.right;

    if (left is TAbstract and !(right is TVar))
      left = left.instantiate(typeVar);
    
    if (right is TAbstract and !(left is TVar))
      right = right.instantiate(typeVar);
    
    return super.unify(constraint.__class__(left, right));
  }

  // Calculate the type of [expr], inferring it if necessary.
  type(expr) => {
    let type = this.system.literalType(expr);
    if (type) return type;

    type = this.infer(expr);

    // instantiate abstract types if we have
    // annotations to incorporate.
    if (len(annotations(expr)) > 0 and type is TAbstract)
      type = type.instantiate(typeVar);

    return this.unifyAnnotations(expr, type);
  }
}

class PolyTypeSystem extends AdhocTypeSystem {
  typify(value) => {
    if (vType(value) == OFunction)
      return TAbstract(value);

    return super.typify(value);
  }
}

PolyTypeSystem.TypeStateClass = PolyTypeState;
