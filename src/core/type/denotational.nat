
class CompositionError extends Error {}

class Domain extends Type {
  init(name, *elements) => {
    this.name = name;
    this.elements = Set(..elements);
  }

  substitute(c) => this;
  str() => this.name;

  __iter__() => iter(this.elements);
  // functions are not hashable atm.
  __in__(value) => hashable(value) and value in this.elements;
  __eq__(that) => this.elements == that.elements;
}

class DenotationalTypeState extends PolyTypeState {
  unify(constraint: Constraint) => {
    if (constraint is SubtypeConstraint) {
      if (constraint.left is Domain and constraint.right is Domain) {
        return constraint.left.elements.subsetEq(constraint.right.elements);
      }
    }

    return super.unify(constraint);
  }
}

class DenotationalTypeSystem extends PolyTypeSystem {
  init() => {
    // map from names to domains.
    this.domains = Map();
    // map from literals to their domain names.
    this.literals = Map();
  }

  resetState() => {
    this.state = this.TypeStateClass(this, false);
  }

  addDomain(domain: Domain) => {
    this.domains[domain.name] = domain;

    for (element in domain) {
      this.literals[element] = domain.name;
    }
  }

  literalType(value) => {
    if (hashable(value) and value in this.literals)
      return this.domains[this.literals[value]];

    return super.literalType(value);
  }
}

DenotationalTypeSystem.TypeStateClass = DenotationalTypeState;

class TypedTree extends Tree {
  init(data, children, type: Type) => {
    super.init(data, children);
    this.type = type;
  }
  str() => {
    let s = "[";
    s = s + this.type.str();
    for (x in this.children)
      s = s + " " + x.str();
    s = s + "]";
    return s;
  }
}

class CompositionSystem {
  init(binaryRules, unaryRules, typeShifters) => {
    this.binaryRules = binaryRules;
    this.unaryRules = unaryRules;
    this.typeShifters = typeShifters;
  }

  // Decorate the tree with type information.
  decorate(node: Tree) => {
    if (node.leaf()) {
      let data = node.data;
      return TypedTree(() => data, [], TypeSystem.type(node.data));
    }

    if (node.unary()) {
      let child = this.decorate(node[0]);

      return TypedTree(child.data, [child], child.type);
    }

    if (node.binary()) {
      let left = this.decorate(node[0]),
          right = this.decorate(node[1]);

      for (rule in this.binaryRules) {
        let l = left.data, r = right.data, data = () => rule(l(), r());

        let type = TypeSystem.type(data);

        if (type.range) {
          return TypedTree(data, [left, right], type);
        }
      }

      return TypedTree(node.data, node.children, nil);
    }

    throw CompositionError("Nonbinary tree.");
  }

  type(node: Tree) => this.decorate(node).type;
  interpret(node: Tree) => this.decorate(node).data;
  typecheck(node: Tree) => this.type(node) != nil;
}