
class Tree extends Object {
  init() => {
    this.data = nil;
    this.children = [];
  }

  setData(data) => {
    this.data = data;
    return this;
  }

  // Add a [child] to the tree, first converting it to a [Tree]
  // object if it's not already. The compiler uses this method.
  addChild(child) => {
    if (type(child) != Tree)
      child = Tree().setData(child);

    this.children.push(child);
    return this;
  }

  // Subscript access is to children.
  __get__(idx) => this.children[idx];

  __iter__() => {
    let nodes = this.depthFirst();
    return Iterator(nodes, 0, len(nodes));
  }

  depthFirst() => {
    let seq = [this];

    for (child in this.children)
      seq = seq.concat(child.depthFirst());

    return seq;
  }

  isLeaf() => len(this.children) == 0;

  leaves() => {
    if (this.isLeaf()) return [this.data];

    return [leaf | child in this.children, leaf in child.leaves()];
  }

  map(fn) => {
    let tree = Tree();

    tree.setData(fn(this.data));

    for (child in this.children)
      tree.children.push(child.map(fn));

    return tree;
  }

  foldM(fn) => {
    let acc = [];

    for (node in this.depthFirst())
      acc = acc.mconcat(fn(node));

    return acc;
  }

  reduce(fn, acc) => {
    for (node in this.depthFirst())
      acc = fn(acc, node);

    return acc;
  }

  fold(fn, acc) => this.reduce(
    (acc, node) => fn(acc, node.data), acc
  );
}