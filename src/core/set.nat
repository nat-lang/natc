
class Set extends Object {
  init(*elements) => {
    this.inner = Map();

    for (let i = 0; i < len(elements); i = i + 1) {
      this.inner[elements[i]] = true;
    }

    // instance method.
    this.tex = () => "\{#{join(this.elements().map(x => x.tex()), ", ")}\}";
  }

  // The elements of the set are the keys of the underlying map.
  elements() => this.inner.keys();

  // Calling a set is shorthand for the membership predicate,
  // so that the set behaves like its characteristic function.
  call(element) => element in this;

  __set__(key, value) => {
    this.inner[key] = value;
    return this;
  }

  __get__(key) => this.inner[key];
  __in__(key) => key in this.inner;

  // The compiler uses this method when building set comprehensions.
  add(element) => this.__set__(element, true);

  __len__() => len(this.elements());

  // Iteration is over elements.
  __iter__() => iter(this.elements());

  // Hash the elements and sum them.
  hash() => {
    // begin with an offset, so that hash(1) != {1}.hash() != {{1}}.hash().
    let sum = 1;

    for (x in this.elements()) {
      sum = sum + hash(x);
    }

    return sum;
  }

  // Is [this] a subset of or equal to [that]?
  subsetEq(that) => {
    if (len(this) > len(that))
      return false;

    for (x in this) {
      if (!that(x))
        return false;
    }
  
    return true;
  }

  // Is [this] a proper subset of [that]?
  subset(that) => {
    if (len(this) == len(that))
      return false;

    return this.subsetEq(that);
  }

  // Is [this] a proper superset of [that]?
  supset(that) => that.subset(this);

  // Is [this] a superset of or equal to [that]?
  supsetEq(that) => that.subsetEq(this);

  // Is [this] equal to [that]?
  __eq__(that) => this.subsetEq(that) and that.subsetEq(this);

  union(that) => {
    let set = {};

    for (x in this)
      set.add(x);

    for (x in that)
      set.add(x);

    return set;
  }

  infix &(that) => this.union(that);

  intersection(that) => {
    let set = {};

    for (x in this)
      if (x in that)
        set.add(x);
    
    return set;
  }

  // Relative complement of [that] in [this].
  complement(that) => {
    let set = {};

    for (x in this)
      if (!that(x))
        set.add(x);
    
    return set;
  }

  copy() => ({x | x in this});

  powerset() => {
    let powerset = {};

    for (element in this) {
      for (set in powerset) {
        let x = set.copy().add(element);
        powerset.add(x);
      }
      powerset.add({element});
    }

    powerset.add({});

    return powerset;
  }

  map(fn) => this.elements().map(fn);
  reduce(fn, acc) => this.elements().reduce(fn, acc);
  all(predicate) => this.elements().all(predicate);
  some(predicate) => this.elements().some(predicate);
  find(predicate) => {
    for (x in this)
      if (predicate(x))
        return x;
    throw Error("Couldn't find an element for #{predicate}.");
  }

  str() => "{#{join([str(x) | x in this.elements()], ", ")}}";
  tex(ast: ASTArgumentSequence) => "\{#{ast.tex()}\}";
  pp() => {
    print this.str();
  }
  print() => print(this.str());

  toSeq() => this.elements();
  fromSeq(seq: Sequential) => Set(..seq);
}

let union = (*sets) => sets.reduce(
  (big, set) => big & set,
  {}
);

class Poset {
  init(X: Set, rel) => {
    this.X = X;
    this.rel = rel;
  }

  assertSubset(Y: Set) => {
    if (!(Y <= this.X))
      throw Error("Expecting subset of #{this.X}, got #{Y}.");
  }

  assertElement(x) => {
    if (x not in this.X)
      throw Error("Expecting #{x} to be in #{this.X}.");
  }

  isUpperBound(x, Y: Set) => {
    this.assertElement(x);
    this.assertSubset(Y);
    return Y.all(y => this.rel(y, x));
  }

  isLowerBound(x, Y: Set) => {
    this.assertElement(x);
    this.assertSubset(Y);
    return Y.all(y => this.rel(x, y));
  }

  isLeastUpperBound(x, Y: Set) => this.isUpperBound(x, Y) && this.X.all(
    x' => this.isUpperBound(x', Y) implies this.rel(x, x')
  );

  isGreatestLowerBound(x, Y) => this.isLowerBound(x, Y) && this.X.all(
    x' => this.isLowerBound(x', Y) implies this.rel(x', x)
  );

  downwardClosure(Y: Set) => ({x | x in this.X, Y.some(y => this.rel(x, y))});
  upwardClosure(Y: Set) => ({x | x in this.X, Y.some(y => this.rel(y, x))});

  isDownwardClosed(Y: Set) => {
    this.assertSubset(Y);
    return Y == this.downwardClosure(Y);
  }

  isUpwardClosed(Y: Set) => {
    this.assertSubset(Y);
    return Y == this.upwardClosure(Y);
  }

  isLattice() => [{x,y} | x in this.X, y in this.X, x != y].all(
    Y => this.X.some(x => this.isLeastUpperBound(x, Y))
          && this.X.some(x => this.isGreatestLowerBound(x, Y))
  );

  asLattice() => {
    if (!this.isLattice())
      throw Error("Not a lattice.");
    return Lattice(
      this.X,
      (x,y) => this.X.find(z => this.isLeastUpperBound(z, {x,y})),
      (x,y) => this.X.find(z => this.isGreatestLowerBound(z, {x,y}))
    );
  }
}

class Lattice {
  init(X: Set, join, meet) => {
    this.X = X;
    this.join = join;
    this.meet = meet;
  }

  isComplete() => this.X.powerset().all(
    Y => this.sum(Y) in this.X
  );

  sum(Y: Set) => this.X.reduce(
    (x, y) => this.join(x, y), this.X[0]
  );

  top() => this.X.find(x => this.X.all(x' => this.meet(x, x') == x'));
  bottom() => this.X.find(x => this.X.all(x' => this.join(x, x') == x'));
}