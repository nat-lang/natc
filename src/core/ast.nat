class NameSupply {
  init() => {
    this.next = 0;
  }
  fresh() => {
    this.next = this.next + 1;
    return this.next;
  }
}

class ASTNode extends Tree {
  // Give the tree's variables uuids; make sure upvalues
  // are identified with the locals they close over.
  stampVariables(cb) => {
    let uuids = NameSupply();
    let globals = Map();

    let rename = (node: ASTVar, env: Map) => {
      if (!env[node.data])
        env[node.data] = uuids.fresh();
      node.uuid = env[node.data];
    };

    class VarEnv {
      init(upvalues) => {
        this.locals = Map();
        this.upvalues = upvalues;
      }
    }

    this.visit((node, varEnv) => {
      if (node is ASTClosure) {
        let closureEnv = VarEnv(varEnv.upvalues);
        for (param in node.signature.params) {
          let local = param[0];
          rename(local, closureEnv.locals);
        }

        for (upvalue in node.upvalues) {
          if (!closureEnv.upvalues[upvalue.data]) {
            closureEnv.upvalues[upvalue.data] = varEnv.locals[upvalue.localId];
          }
        }

        return closureEnv;
      }

      if (node is ASTLocal)
        rename(node, varEnv.locals);

      if (node is ASTUpvalue) {
        if (!varEnv.upvalues[node.data])
          throw Error("Upvalue (" + str(node.data) + ") missing uuid.");
        node.uuid = varEnv.upvalues[node.data];
      }

      if (node is ASTGlobal)
        rename(node, globals);

      cb(node);

      return varEnv;
    }, VarEnv(Map()));
  }
}

class ASTStatement extends ASTNode {
  init(*children) => {
    this.children = children;
  }
}

class ASTExpr extends ASTNode {
  init(data) => {
    this.data = data;
    this.children = [];
  }
}

class ASTAssignment extends ASTStatement {}
class ASTLocalValueAssignment extends ASTAssignment {}
class ASTTypeAssignment extends ASTStatement {}
class ASTGlobalTypeAssignment extends ASTTypeAssignment {}
class ASTLocalTypeAssignment extends ASTTypeAssignment {}
class ASTReturn extends ASTStatement {}
class ASTImplicitReturn extends ASTReturn {}
class ASTExprStatement extends ASTStatement {}

class ASTLiteral extends ASTExpr {
  resolve() => this.data;
}
class ASTNegation extends ASTExpr {}

class ASTVar extends ASTExpr {
  init(id) => {
    super.init(id);
    this.uuid = nil;
  }

  hash() => {
    if (!this.uuid) throw Error("Can't hash 'ASTVar' without uuid.");

    return hash(this.uuid);
  }
}

class ASTLocal extends ASTVar {}
class ASTGlobal extends ASTVar {
  resolve() => globals()[this.data];
}
class ASTUpvalue extends ASTVar {
  init(id, localId) => {
    super.init(id);
    this.localId = localId;
  }
}

class ASTArgumentSequence extends ASTExpr {
  init(args) => {
    this.children = args;
  }
  resolve() => this.children.map((node) => node.resolve());
}

class ASTApp extends ASTExprStatement {
  evaluate() => {
    let fn = this[0].resolve();
    let args = this[1].resolve();

    return fn(..args);
  }

  resolve() => this.evaluate();
}

class ASTInvocation extends ASTApp {
  evaluate() => {
    let obj = this[0].resolve();
    let key = this[1].resolve();
    let args = this[2].resolve();

    return obj[key](..args);
  }

  resolve() => this.evaluate();
}

class ASTSignature extends ASTNode {
  init(arity) => {
    this.arity = arity;
    this.params = [];
  }

  isComplete() => len(this.params) == this.arity;
}

class ASTClosure extends ASTExpr {
  init(name, function, arity, upvalues) => {
    this.name = name;
    this.function = function;
    this.signature = ASTSignature(arity);
    this.children = [];
    this.upvalues = upvalues;
  }

  // expressions.

  opLiteral(value) => ASTLiteral(value);
  opNot(value) => ASTNegation(value);
  opGetLocal(slot) => ASTLocal(slot);
  opGetGlobal(name) => ASTGlobal(name);
  opGetUpvalue(slot, localSlot) => ASTUpvalue(slot, localSlot);
  opCall(fn, *args) => ASTApp(fn, ASTArgumentSequence(args));
  opInvoke(obj, key, *args) => ASTInvocation(obj, key, ASTArgumentSequence(args));

  // statements.

  opExprStatement(expr) => {
    let node = ASTExprStatement(expr);
    this.children.push(node);
  }

  opSetLocalValue(slot, value) => {
    let local = ASTLocal(slot);
    let node = ASTLocalValueAssignment(local, value);
    this.children.push(node);
  }

  opSetLocalType(slot, value) => {
    let local = ASTLocal(slot);
    let node = ASTLocalTypeAssignment(local, value);

    if (this.signature.isComplete())
      this.children.push(node);
    else
      this.signature.params.push(node);
  }

  opReturn(expr) => {
    let node = ASTReturn(expr);
    this.children.push(node);
  }

  opImplicitReturn(expr) => {
    let node = ASTImplicitReturn(expr);
    this.children.push(node);
  }
}