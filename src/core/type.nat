class TypeError extends Error {}

let isSubclass = (a, b) => {
  if (vType(a) != OClass or vType(b) != OClass) 
    return false;
  
  let klass = a;

  while (klass != nil) {
    if (klass == b) return true;
    klass = klass.__superclass__;
  }

  return false;
};

// Is [a] an instance of [b]?
let infix(5) is = (a, b) => {
  let aVmType = vType(a);
  let bVmType = vType(b);

  if (aVmType != OInstance or bVmType != OClass)
    return false;

  return isSubclass(a.__class__, b);
};

class CType {}

class CBool extends CType {}
class CNil extends CType {}
class CNumber extends CType {}
class CObject extends CType {}
class CUndef extends CType {}

class OClass extends CObject {}
class OInstance extends CObject {}
class OString extends CObject {}
class OClosure extends CObject {}
class OSequence extends CObject {}

class Type {
  pp() => {
    print this;
  }
}

class TVar extends Type {
  init(name) => {
    this.name = name;
  }
  hash() => hash(this.name);
  __eq__(other) => this.name == other.name;
}

class TSum extends Type {}
class TProduct extends Tuple {}

class TVoid extends Type {}
class TBoolean extends Type {}
class TNumber extends Type {}
class TString extends Type {}
class TFunction extends Type {
  init(domain, range) => {
    this.domain = domain;
    this.range = range;
  }

  // the subtype relation.
  __eq__(other) => this.domain == other.domain and this.range == other.range;

  pp() => {
    print this.domain;
    print this.range;
  }
}
class TClass extends Type {}

class Constraint {
  init(left, right) => {
    this.left = left;
    this.right = right;
  }
  substitute(type: Type) => {
    if (type == this.left)
      return this.right;
    return type;
  }
}

class Solution extends Map {
  // fix me
  // __iter__() => iter([Constraint(e[0], e[1]) | e in this.entries()]);

  __iter__() => {
    let seq = [];
    for (x in this.entries())
      seq.push(Constraint(x[0], x[1]));
    return iter(seq);
  }

  apply(c: Constraint) => {
    for (sub in this) {
      c.left = sub.substitute(c.left);
      c.right = sub.substitute(c.right);
    }

    return c;
  }

  update(constraint: Constraint) => {
    if (constraint.left is TVar)
      this[constraint.left] = constraint.right;
    else if (constraint.right is TVar)
      this[constraint.right] = constraint.left;
  }
}

class NameSupply {
  init() => {
    this.next = 0;
  }
  fresh() => {
    this.next = this.next + 1;
    return this.next;
  }
}

class TypeVarSupply extends NameSupply {
  fresh() => TVar(super.fresh());
}

let void = TVoid();
let bool = TBoolean();
let num = TNumber();
let string = TString();
let infix -> = TFunction;
let tClass = TClass();

// Map vm types to object language types.
let type = (value) => {
  let vmType = vType(value);

  if (vmType == CNil) return void;
  if (vmType == CBool) return bool;
  if (vmType == CNumber) return num;
  if (vmType == OString) return string; 
  if (vmType == OInstance) return value.__class__;
  if (vmType == OClass) return tClass;
  if (vmType == OClosure) return TFunction;
};

class TypeState {
  init(typeEnv: Map) => {
    // map from variables to types.
    this.typeEnv = typeEnv;
    // name supply.
    this.typeVars = TypeVarSupply();
    // constraint stack.
    this.constraints = [];
    // most general unifiers.
    this.solution = Solution();
  }

  lookup(node: ASTVar) => {
    if (!this.typeEnv[node])
      this.typeEnv[node] = this.typeVars.fresh();

    return this.typeEnv[node];
  }

  constrain(node) => {
    if (node is ASTClosure) {
      let f = (env: Map, node: ASTLocalTypeAssignment) => {
        let var = node[0];
        let val = node[1];

        let pType = val.resolve();

        if (pType == nil)
          env[var.uuid] = this.typeVars.fresh();
        else
          env[var.uuid] = pType;

        return env;
      };
  
      let localEnv = node.signature.params.reduce(f, Map());
      let params = localEnv.values();

      // this needs to happen in localEnv.
      node.children.map(this.constrain);
  
      // type of a constant function? type of return value(s)?
      if (len(params) == 0)
        return this.typeVars.fresh();
      if (len(params) == 1)
        // fixme:
        // return params[0] -> this.typeVars.fresh();
        return TFunction(params[0], this.typeVars.fresh());
      else
        return params -> this.typeVars.fresh();
    }

    if (node is ASTLiteral)
      return type(node.data);

    if (node is ASTVar)
      return this.lookup(node);
    
    if (node is ASTArgumentSequence) {
      let tArgs = node.children.map(this.constrain);

      if (len(tArgs) > 1)
        return tArgs;
      else
        return tArgs[0];
    }

    if (node is ASTApp) {
      let func = node[0];
      let args = node[1];

      let tFunc = this.constrain(func);
      let tArgs = this.constrain(args);

      let tApp = this.typeVars.fresh();
      this.constraints.push(Constraint(tFunc, tArgs -> tApp));
      return tApp;
    }

    if (node is ASTLocalTypeAssignment) {
      let var = node[0];
      let val = node[1];

      if (var.uuid in this.typeEnv)
        throw TypeError("Variable already has a type annotation.");
    
      this.typeEnv[var.uuid] = val.resolve();

      return void;
    }

    if (node is ASTAssignment) {
      let var = node[0];
      let val = node[1];

      let tVar = this.lookup(var);
      let tVal = this.constrain(val);

      this.constraints.push(Constraint(tVar, tVal));

      // this should eventually respect a possibly user
      // defined __set__ method that returns something.
      return void;
    }

    if (node is ASTExprStatement)
      return this.constrain(node[0]);

    if (node is ASTReturn) 
      return this.constrain(node[0]);

    throw TypeError("Unexpected syntax.");
  } 

  unify() => {
    let unsolved = [];
    
    while (len(this.constraints) > 0) {
      let constraint = this.constraints.pop();

      if (constraint.left is TVar or constraint.right is TVar) {
        this.solution.update(constraint);
        this.constraints = this.constraints.map(this.solution.apply);

      } else if (constraint.left is TFunction and constraint.right is TFunction) {
        let left = constraint.left;
        let right = constraint.right;

        this.constraints.add(
          Constraint(left.domain, right.domain),
          Constraint(left.range, right.range)
        );
      } else if (constraint.left != constraint.right) {
        unsolved.push(constraint);
      }
    }

    this.constraints = unsolved;
  }

  // Compute the most general type for each variable in
  // the original environment.
  principal() => {
    let env = Map();

    for (x in this.typeEnv) {
      for (s in this.solution) {
        let k = x[0];
        let v = x[1];

        env[k] = s.substitute(v);
      }
    }

    return env;
  }

  unified() => len(this.constraints) == 0;
  success() => this.unified();
  failure() => !this.unified();
}

let typecheck = (expr) => {
  let ast <- expr;
  let uuids = NameSupply();

  let typeEnv = Map();

  // give the variables uuids.

  let globals = Map();
  let annotations = globalTypeEnv();

  ast.visit((node, locals) => {
    let rename = (node, env) => {
      if (!env[node.data])
        env[node.data] = uuids.fresh();
      node.uuid = env[node.data];
    };

    if (node is ASTClosure) {
      let localEnv = Map();
      for (param in node.signature.params)
        rename(param, localEnv);
      return localEnv;
    }
  
    if (node is ASTLocal) rename(node, locals);
    if (node is ASTGlobal) {
      rename(node, globals);

      if (node.data in annotations) {
        typeEnv[node] = annotations[node.data];
      }
    }

    return locals;
  }, Map());

  let state = TypeState(typeEnv);

  state.constrain(ast);
  state.unify();

  return state;
};
