let typecheck = x => assert(
  PolyTypeSystem.typecheck(x).success()
);
let typefail = x => assert(
  PolyTypeSystem.typecheck(x).failure()
);

let type = PolyTypeSystem.type;

// type generalization, aka abstraction.

let a = TVar("a"),
    b = TVar("b"),
    c = TVar("c"),
    d = TVar("d");

let h = TAbstract.generalize(a);
assert(h.fn(b) == b);

let f = TAbstract.generalize(a -> b);
assert(f.fn(c,d) == c -> d);

let g = TAbstract.generalize(TProduct([a,b]));
assert(g.fn(c,d) == TProduct([c,d]));

// the simple type system fails here.

let check = SimpleTypeSystem.typecheck(() => {
  let id = x => x;

  id(1);
  id(true);
  id("string");
});

assert(check.failure());

// but the polymorphic type system succeeds.

// explicit abstraction.

let check = PolyTypeSystem.typecheck(() => {
  let id: (a => a -> a) = x => x;

  id(1);
  id(true);
  id("string");
});

check.ppInsoluble();

let id: (a => a -> a) = x => x;

typecheck(() => {
  id(1);
  id(true);
  id("string");
});

// implicit abstraction in let annotation.

// one parameter.

let f: w -> w = x => x;

let t = annotations(f)[0];

assert(vType(t) == OFunction);

assert(t(num) is TFunction);
assert(t(num).domain == num);
assert(t(num).range == num);

typecheck(() => {
  id(1);
  id(true);
  id("string");
});

typecheck(() => {
  let id: w -> w = x => x;

  id(1);
  id(true);
  id("string");
});

// two parameters.

let f: x -> y = x => x;

let t = annotations(f)[0];

assert(vType(t) == OFunction);

assert(t(num, string) is TFunction);
assert(t(num, string).domain == num);
assert(t(num, string).range == string);

// implicit abstraction in parameter annotation.

let id = (x: w) => x;

typecheck(() => {
  id(1);
  id(true);
  id("string");
});

typecheck(() => {
  let id = (x: w) => x;

  id(1);
  id(true);
  id("string");
});

// identity between type variables is preserved.

typecheck((x: w -> z, y: u) => y(x));
typecheck((x: w -> z, y: w) => x(y));

typefail((x: w -> z, y: w) => y(x));

// nested abstract types normalize to a single first order type.

let t = type(x y => y);

assert(t is TAbstract);
assert(t.fn(num,num) == num -> (num -> num));

// abstract types become concrete when saturated.

let f: w -> (w -> w) = x y => y;

typecheck(() => f(1)(1));
typecheck(() => f(true)(true));

typefail(() => f(true)(1));
typefail(() => f(1)(true));

let infix @ : ((v -> w), (u -> v)) -> (u -> w)
            = (f, g) => x => f(g(x));

typecheck((f: bool -> num, g: num -> bool, x: num) => (f @ g)(x));

typefail((f: num -> num, g: num -> bool, x: num) => (f @ g)(x));

typecheck(
  (x: num, h: num -> bool, g: bool -> string, f: string -> num) => {
    ((f @ g) @ h)(x);
    (f @ (g @ h))(x);
  }
);

// poly adhoc.

let f = (a: x -> y, b: x) => a(b)
      | (a: x, b: x -> y) => b(a);

let g: num -> string = x => "y";
let h: string -> num = x => 1;

typecheck(() => f(g, 1));
typecheck(() => f(1, g));
typecheck(() => f(h, f(1, g)));
typecheck(() => f(h, f(g, 1)));
typecheck(() => f(f(g, 1), h));
typecheck(() => f(f(1, g), h));

typefail(() => f(g, "x"));
typefail(() => f("x", g));
typefail(() => f(h, f("x", g)));
typefail(() => f(h, f(g, "x")));
typefail(() => f(f(g, "x"), h));
typefail(() => f(f("x", g), h));

// reconstruction.

// first order succeeds.

typecheck(() => {
  let id = x => x;

  id(1);
  id(true);
  id("string");
});

// second order fails.

typefail((id) => {
  id(1);
  id(true);
  id("string");
});
