let typecheck = (*environments) => environments.map(
  env => assert(
    PolyTypeSystem.typecheck(env).success()
  )
);
let typefail = x => assert(
  PolyTypeSystem.typecheck(x).failure()
);

let type = PolyTypeSystem.type;

// types with variables can be generalized into
// abstract types, functions from types to types.

let a = TVar("a"),
    b = TVar("b"),
    c = TVar("c"),
    d = TVar("d");

let h = TGeneralization(a);
assert(h.fn(b) == b);

let f = TGeneralization(a -> b);
assert(f.fn(c,d) == c -> d);

let g = TGeneralization(TProduct([a,b]));
assert(g.fn(c,d) == TProduct([c,d]));

// the simple type system can't type the id function.

let check = SimpleTypeSystem.typecheck(() => {
  let id = x => x;

  id(1);
  id(true);
  id("string");
});

assert(check.failure());

// but the polymorphic type system can, with the
// aid of abstract types.

// with explicit abstraction.

let check = PolyTypeSystem.typecheck(() => {
  let id: (a => a -> a) = x => x;

  id(1);
  id(true);
  id("string");
});

let id: (a => a -> a) = x => x;

typecheck(() => {
  id(1);
  id(true);
  id("string");
});

// and with implicit abstraction.

// with either one type parameter.

let id: w -> w = x => x;

let abstract = annotations(id)[0];
let concrete = abstract(num);

assert(vType(abstract) == OFunction);

assert(concrete is TFunction);
assert(concrete.domain == num);
assert(concrete.range == num);

typecheck(() => {
  id(1);
  id(true);
  id("string");
});

typecheck(() => {
  let id: w -> w = x => x;

  id(1);
  id(true);
  id("string");
});

// or n + 1 type parameters.

let f: x -> (y -> (y -> y)) = a b c => c;

let abstract = annotations(f)[0];
let concrete = abstract(num, string);

assert(vType(abstract) == OFunction);

assert(concrete is TFunction);
assert(concrete.domain == num);
assert(concrete.range is TFunction);
assert(concrete.range.domain == string);
assert(concrete.range.range is TFunction);
assert(concrete.range.range.domain == string);
assert(concrete.range.range.range == string);

typecheck(() => {
  f(1)(1)(1);
  f(1)(true)(false);
  f(1)("foo")("bar");
});

typefail(() => id(1)(1)(true));
typefail(() => id(1)(true)("bar"));
typefail(() => id(1)("foo")(1));

// abstractions can be implicit in parameter annotations.

let id = (x: w) => x;

typecheck(() => {
  id(1);
  id(true);
  id("string");
});

typecheck(() => {
  let id = (x: w) => x;

  id(1);
  id(true);
  id("string");
});

// implicit abstraction preserves identity between type variables.

typecheck((x: w -> z, y: u) => y(x));
typecheck((x: w -> z, y: w) => x(y));

typefail((x: w -> z, y: w) => y(x));

// nested abstract types normalize to a single first order type.

let t = type(x y => y);

assert(t is TAbstract);
assert(t.fn(num,num) == num -> (num -> num));

// abstract types become concrete when saturated.

// in declaration annotations.

let f: w -> (w -> w) = x y => y;

typecheck(() => f(1)(1));
typecheck(() => f(true)(true));

typefail(() => f(true)(1));
typefail(() => f(1)(true));

let infix @ : ((v -> w), (u -> v)) -> (u -> w)
            = (f, g) => x => f(g(x));

typecheck((f: bool -> num, g: num -> bool, x: num) => (f @ g)(x));

typefail((f: num -> bool, g: bool -> num, x: num) => (f @ g)(x));

typecheck(
  (x: num, h: num -> bool, g: bool -> string, f: string -> num) => {
    1 + ((f @ g) @ h)(x);
    1 + (f @ (g @ h))(x);
  }
);

// and in parameter annotations.

// ...

// the polymorphic type system types overloads
// with abstract cases.

// identity between type variables in cases is preserved.

let f = (a: x -> y, b: x) => a(b)
      | (a: x, b: x -> y) => b(a);

let g: num -> string = x => "y";
let h: string -> num = x => 1;

typecheck(() => f(g, 1));
typecheck(() => f(1, g));
typecheck(() => f(h, f(1, g)));
typecheck(() => f(h, f(g, 1)));
typecheck(() => f(f(g, 1), h));
typecheck(() => f(f(1, g), h));

typefail(() => f(g, "x"));
typefail(() => f("x", g));
typefail(() => f(h, f("x", g)));
typefail(() => f(h, f(g, "x")));
typefail(() => f(f(g, "x"), h));
typefail(() => f(f("x", g), h));

// reconstruction.

let a = Type(), b = Type(), c = Type();

let infix unifies = (x, y) => PolyTypeSystem.newState().unify(x ~ y);

// first order succeeds.

typecheck(() => {
  let id = x => x;

  id(1);
  id(true);
  id("string");
});

// second order fails.

typefail(id => {
  id(1);
  id(true);
  id("string");
});

// the type of forward application is inferrable.

let f = g x => g(x);
let t = type(f);

assert(t unifies ((a -> b) -> (a -> b)));
assert(t unifies ((b -> a) -> (b -> a)));

assert(!(t unifies ((a -> b) -> (b -> a))));
assert(!(t unifies ((b -> a) -> (a -> b))));

assert(!(t unifies ((a -> a) -> (a -> b))));
assert(!(t unifies ((b -> b) -> (a -> b))));

assert(!(t unifies ((a -> b) -> (a -> a))));
assert(!(t unifies ((a -> b) -> (b -> b))));

// the type of backward application is inferrable.

let f = x g => g(x);
let t = type(f);

assert(t unifies (a -> ((a -> b) -> b)));
assert(t unifies (b -> ((b -> a) -> a)));

assert(!(t unifies (b -> ((a -> b) -> b))));
assert(!(t unifies (a -> ((b -> a) -> a))));

assert(!(t unifies (a -> ((b -> a) -> b))));
assert(!(t unifies (b -> ((a -> b) -> a))));

assert(!(t unifies (a -> ((a -> b) -> a))));
assert(!(t unifies (b -> ((b -> a) -> b))));

// the type of composition is inferrable.

let @ = f g x => f(g(x));
let t = type(@);

assert(t unifies ((a -> b) -> ((c -> a) -> (c -> b))));
assert(!(t unifies ((c -> a) -> ((a -> b) -> (c -> b)))));

// the type of type driven application is inferrable.

let f = (a: x -> y, b: x) => a(b)
      | (a: x, b: x -> y) => b(a);

let t = type(f);

assert(t unifies ((a -> b, a) -> b) <+> ((a, a -> b) -> b));
assert(t unifies ((b -> a, b) -> a) <+> ((b, b -> a) -> a));

// fixme.
// assert(!(t unifies ((a -> b, b) -> b) <+> ((a, a -> b) -> b)));

// the type of curried type driven application is inferrable.

let f = (a: x -> y) => ((b: x) => a(b)) | (a: x) => ((b: x -> y) => b(a));

let t = type(f);

