import src/core/type/poly

// type generalization, aka abstraction.

let a = TVar("a"),
    b = TVar("b"),
    c = TVar("c"),
    d = TVar("d");

let h = TAbstract.generalize(a);
assert(h.fn(b) == b);

let f = TAbstract.generalize(a -> b);
assert(f.fn(c,d) == c -> d);

let g = TAbstract.generalize(TProduct([a,b]));
assert(g.fn(c,d) == TProduct([c,d]));

let check;

// the simple type system fails here.

check = SimpleTypeSystem.typecheck(() => {
  let id = x => x;

  id(1);
  id(true);
  id("string");
});

assert(check.failure());

// but the polymorphic type system succeeds.

// explicit abstraction.

check = PolyTypeSystem.typecheck(() => {
  let id: (a => a -> a) = x => x;

  id(1);
  id(true);
  id("string");
});

assert(check.success());

let id: (a => a -> a) = x => x;

check = PolyTypeSystem.typecheck(() => {
  id(1);
  id(true);
  id("string");
});

assert(check.success());

// implicit abstraction in let annotation.

// one parameter.

let f: w -> w = x => x;
let t = globalTypeEnv()["f"];

assert(vType(t) == OFunction);

assert(t(num) is TFunction);
assert(t(num).domain == num);
assert(t(num).range == num);

check = PolyTypeSystem.typecheck(() => {
  id(1);
  id(true);
  id("string");
});

assert(check.success());

check = PolyTypeSystem.typecheck(() => {
  let id: w -> w = x => x;

  id(1);
  id(true);
  id("string");
});

assert(check.success());

// two parameters.

let f: x -> y = x => x;
let t = globalTypeEnv()["f"];

assert(vType(t) == OFunction);

assert(t(num, string) is TFunction);
assert(t(num, string).domain == num);
assert(t(num, string).range == string);

// implicit abstraction in parameter annotation.

let id = (x: w) => x;

check = PolyTypeSystem.typecheck(() => {
  id(1);
  id(true);
  id("string");
});

assert(check.success());

check = PolyTypeSystem.typecheck(() => {
  let id = (x: w) => x;

  id(1);
  id(true);
  id("string");
});

assert(check.success());

// identity between type variables is preserved.

check = PolyTypeSystem.typecheck((x: w -> z, y: u) => y(x));
assert(check.success());

check = PolyTypeSystem.typecheck((x: w -> z, y: w) => y(x));
assert(check.failure());

check = PolyTypeSystem.typecheck((x: w -> z, y: w) => x(y));
assert(check.success());

// reconstruction.

// first order succeeds:

check = PolyTypeSystem.typecheck(() => {
  let id = x => x;

  id(1);
  id(true);
  id("string");
});

assert(check.success());

// second order fails:

check = PolyTypeSystem.typecheck((id) => {
  id(1);
  id(true);
  id("string");
});

assert(check.failure());

// poly adhoc.

let f = (a: x -> y, b: x) => a(b)
      | (a: x, b: x -> y) => b(a);

let g: num -> string = x => "y";
let h: string -> num = x => 1;

check = PolyTypeSystem.typecheck(() => f(g, 1));
assert(check.success());

check = PolyTypeSystem.typecheck(() => f(1, g));
assert(check.success());

check = PolyTypeSystem.typecheck(() => f(h, f(1, g)));
assert(check.success());

check = PolyTypeSystem.typecheck(() => f(h, f(g, 1)));
assert(check.success());

check = PolyTypeSystem.typecheck(() => f(f(g, 1), h));
assert(check.success());

check = PolyTypeSystem.typecheck(() => f(f(1, g), h));
assert(check.success());

check = PolyTypeSystem.typecheck(() => f(g, "x"));
assert(check.failure());

check = PolyTypeSystem.typecheck(() => f("x", g));
assert(check.failure());

check = PolyTypeSystem.typecheck(() => f(h, f("x", g)));
assert(check.failure());

check = PolyTypeSystem.typecheck(() => f(h, f(g, "x")));
assert(check.failure());

check = PolyTypeSystem.typecheck(() => f(f(g, "x"), h));
assert(check.failure());

check = PolyTypeSystem.typecheck(() => f(f("x", g), h));
assert(check.failure());
