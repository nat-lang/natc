
// constants.

const Agnetha, Bjorn, Benny, Carlos, Paco, Frida, Ariel;

// types.

TypeSystem = DenotationalTypeSystem();

dom e = {Agnetha, Bjorn, Benny, Carlos, Paco, Frida, Ariel};
dom t = {true, false};

bool = t;

// common nouns.

let Singer = {};
let singer: e -> t = x => x in Singer;

let Millionaire = {};
let millionaire: e -> t = x => x in Millionaire;

let Norwegian = {};
let norwegian: e -> t = x => x in Norwegian;

// intransitive verbs.

let Smile = {};
let smiled: e -> t = x => x in Smile;

// transitive verbs.

let Love = {(Agnetha, Agnetha)};
let loves: e -> (e -> t) = x y => (x,y) in Love;

let Shave = {};
let shaves: e -> (e -> t) = x y => (x,y) in Shave;

// ditransitive verbs.

let Introduce = {};
let introduced: e -> (e -> (e -> t)) = x y z => (x,y,z) in Introduce;

// prepositions.

let to : e -> ((e -> (e -> t)) -> (e -> t))
       = x p y => p(x)(y);

let self1 : (e -> (e -> t)) -> (e -> t)
          = p x => p(x)(x);

let self2 : (e -> (e -> (e -> t))) -> (e -> (e -> t))
          = p x y => p(x)(y)(y);

let self3 : (e -> (e -> (e -> t))) -> (e -> (e -> t))
          = p x y => p(x)(y)(x);

let With = {};
let with: e -> (e -> t) = x y => (x,y) in With;

let of: e -> e = x => x;

// 1-place adjectives.

let Kind = {};
let kind: e -> t = x => x in Kind;

let Snore = {};
let snores: e -> t = x => x in Snore;

// 2-place adjectives.

let Proud = {};
let proud: e -> (e -> t) = x y => (x,y) in Proud;

let Hug = {};
let hugged: e -> (e -> t) = x y => (x,y) in Hug;

let Afraid = {};
let afraid: e -> (e -> t) = x y => (x,y) in Afraid;

// copula.

let is': (e -> t) -> (e -> t) = p => p;

// negation.

let not: (e -> t) -> (e -> t) = p x => !p(x);

// quantifiers.

let everybody: (e -> t) -> t = p => e.each(p);
let somebody: (e -> t) -> t = p => e.some(p);
let nobody: (e -> t) -> t = p => !e.some(p);

// determiners.

let a: (e -> t) -> (e -> t) = p => p;
let some: (e -> t) -> ((e -> t) -> t) = p q => e.some(x => p(x) and q(x));
let no: (e -> t) -> ((e -> t) -> t) = p q => !e.some(x => p(x) and q(x));
let every: (e -> t) -> ((e -> t) -> t) = p q => e.each(x => !p(x) or q(x));

// composition rules.

let FunctionApplication = (a: x -> y, b: x) => a(b) | (a: x, b: x -> y) => b(a);

let NonBranchingNodes = node => node[0];

let QuantificationalObject
  : (e -> (e -> t)) -> ((e -> t) -> t) -> e -> t
  = r q x => q(z => r(z)(x));

let sys = CompositionSystem(
  [FunctionApplication],
  [NonBranchingNodes],
  [QuantificationalObject]
);

// examples.

let ex0 = [Agnetha smiled];
assert(sys.typecheck(ex0));

let ex1 = [Agnetha [loves Bjorn]];
assert(sys.typecheck(ex1));

let ex2 = [Benny [[introduced Agnetha] [to Bjorn]]];
assert(sys.typecheck(ex2));

let ex3 = [Carlos [self1 shaves]];
assert(sys.typecheck(ex3));

let ex4 = [Carlos [[self2 introduced] Paco]];
assert(sys.typecheck(ex4));

let ex5 = [Carlos [[self3 introduced] Paco]];
assert(sys.typecheck(ex5));

let ex6 = [Bjorn [is' kind]];
assert(sys.typecheck(ex6));

let ex7 = [Frida [is' [with Benny]]];
assert(sys.typecheck(ex7));

let ex8 = [Benny [is' [proud [of Frida]]]];
assert(sys.typecheck(ex8));

let ex9 = [Agnetha [is' [a singer]]];
assert(sys.typecheck(ex9));

let ex10 = [Frida [is' [a [norwegian millionaire]]]];
assert(!sys.typecheck(ex10));

let ex11 = [Bjorn [is' [not kind]]];
assert(sys.typecheck(ex11));

let ex12 = [[every singer] smiled];
assert(sys.typecheck(ex12));

let ex13 = [[a singer] smiled];
assert(!sys.typecheck(ex13));

let ex14 = [everybody snores];
assert(sys.typecheck(ex14));

let ex15 = [somebody [hugged Ariel]];
assert(sys.typecheck(ex15));

let ex16 = [everybody [is' [afraid [of Ariel]]]];
assert(sys.typecheck(ex16));
