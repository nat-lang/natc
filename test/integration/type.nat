

let f;
let env;
let check;

// single argument, implicit return.

f : num -> num;
f = (a) => a + 1;

env = globalTypeEnv();
assert(env["f"] == num -> num);

check = typecheck(() => f(1));
assert(check.success());

check = typecheck(() => f(true));
assert(check.failure());

check = typecheck(() => f(f(1)));
assert(check.success());

check = typecheck(() => f(f(true)));
assert(check.failure());

// fix me.
// check = typecheck(() => f());
// assert(check.failure());

// single argument, explicit return.

check = typecheck(() => {
  return f(1);
});
assert(check.success());

check = typecheck(() => {
  return f(f(1));
});
assert(check.success());

check = typecheck(() => {
  return f(true);
});
assert(check.failure());

check = typecheck(() => {
  return f(f(true));
});
assert(check.failure());

// multiple arguments, implicit return.

f : (num, num) -> num;
f = (a, b) => a + b;

env = globalTypeEnv();
assert(env["f"] == (num, num) -> num);

check = typecheck(() => f(1,1));
assert(check.success());

check = typecheck(() => f(f(1,1),f(1,1)));
assert(check.failure());

check = typecheck(() => f(1, true));
assert(check.failure());

check = typecheck(() => f(true, true));
assert(check.failure());

// multiple arguments, explicit return.

check = typecheck(() => {
  return f(1,1);
});
assert(check.success());

check = typecheck(() => {
  return f(1,true);
});
assert(check.failure());

check = typecheck(() => {
  return f(false,true);
});
assert(check.failure());

// uninitialized variable.

let g: num -> num;
env = globalTypeEnv();
assert(env["g"] == num -> num);

check = typecheck(() => g(1));
assert(check.success());

check = typecheck(() => g(true));
assert(check.failure());

// inline type annotation.

let f: num -> num = (a) => a + 1;

let x: num = 1;
check = typecheck(() => f(x));
assert(check.success());

let y: string = "a";
check = typecheck(() => f(y));
assert(check.failure());

let h: num -> num = (a) => {
  return a + 1;
};

env = globalTypeEnv();
assert(env["h"] == num -> num);

check = typecheck(() => h(2));
assert(check.success());

check = typecheck(() => h(true));
assert(check.failure());

// parameter annotation.

// param constrains the function type.

check = typecheck(() => {
  let k = (a: num) => a;
  k(1);
});
assert(check.success());

check = typecheck(() => {
  let k = (a: num) => a;
  k("a");
});
assert(check.failure());

// multiple params constrain the function type.

check = typecheck(() => {
  let k = (a: num, b: num) => a + b;
  k(1, 1);
});
assert(check.success());

check = typecheck(() => {
  let k = (a: num, b: num) => a + b;
  k(1, "a");
});
assert(check.failure());

// param constrains the function body.

let g: string -> string;
let h: num -> num;

check = typecheck((a: num) => h(a));
assert(check.success());

check = typecheck((a: num) => g(a));
assert(check.failure());

// multiple params constrain the function body.

check = typecheck(
  (a: num, b: num) => {
    h(a);
    h(b);
  }
);
assert(check.success());

check = typecheck(
  (a: num, b: num) => {
    h(a);
    g(b);
  }
);
assert(check.failure());

// homographic local in adjacent scope doesn't clash.

check = typecheck(() => {
  let k = (a: num) => h(a);
  let j = (a: string) => g(a);
});
assert(check.success());

check = typecheck(() => {
  let k = (a: num) => h(a);
  let j = (a: string) => h(a);
});
assert(check.failure());

check = typecheck(() => {
  let k = (a: num) => g(a);
  let j = (a: string) => g(a);
});
assert(check.failure());

// fn declarations constrain their parameter annotations.
// --------------------------------------------
// check = typecheck(() => {
//   let g: string = (a) => a;
// });
// assert(check.failure());

// inference.
// --------------------------------------------

let h;
let hType;
let principal;

// num -> a.

check = typecheck(() => h(1));

principal = check.principal();
hType = principal.find((n) => n.data == "h");

assert(hType is TFunction);
assert(hType.domain is TNumber);
assert(hType.range is TVar);

// bool -> a.

check = typecheck(() => h(true));

principal = check.principal();
hType = principal.find((n) => n.data == "h");

assert(hType is TFunction);
assert(hType.domain is TBoolean);
assert(hType.range is TVar);

// string -> a.

check = typecheck(() => h("a"));

principal = check.principal();
hType = principal.find((n) => n.data == "h");

assert(hType is TFunction);
assert(hType.domain is TString);
assert(hType.range is TVar);