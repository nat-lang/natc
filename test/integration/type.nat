

let f;
let env;
let check;

// (single) implicit return, single argument.

f : num -> num;
f = (a) => a + 1;

env = globalTypeEnv();
assert(env["f"] == num -> num);

check = typecheck(() => f(1));
assert(check.success());

check = typecheck(() => f(true));
assert(check.failure());

// block, single argument.

check = typecheck(() => {
  let a = 1;
  return f(a);
});
assert(check.success());

check = typecheck(() => {
  let a = true;
  return f(a);
});
assert(check.failure());

// (single) implicit return, multiple arguments.

f : (num, num) -> num;
f = (a, b) => a + b + 1;

env = globalTypeEnv();
assert(env["f"] == (num, num) -> num);

check = typecheck(() => f(1,1));
assert(check.success());

check = typecheck(() => f(true, true));
assert(check.failure());

// inline type declaration (a).
// --------------------------------------------
f : num -> num;
f = (a) => a;

let x: num = 1;
check = typecheck(() => f(x));
assert(check.success());

let y: string = "a";
check = typecheck(() => f(y));
assert(check.failure());

let h: num -> num = (a) => {
  return a + 1;
};

env = globalTypeEnv();
assert(env["h"] == num -> num);

check = typecheck(() => h(2));
assert(check.success());

check = typecheck(() => h(true));
assert(check.failure());

// uninitialized.

let g: num -> num;
env = globalTypeEnv();
assert(env["g"] == num -> num);

check = typecheck(() => g(1));
assert(check.success());

check = typecheck(() => g(true));
assert(check.failure());

// inline type declaration (b).
// --------------------------------------------

// param constrains the function type.

check = typecheck(() => {
  let k = (a: num) => a;
  k(1);
});
assert(check.success());

check = typecheck(() => {
  let k = (a: num) => a;
  k("a");
});
assert(check.failure());

// multiple params constrain the function type.

check = typecheck(() => {
  let k = (a: num, b: num) => a + b;
  k(1, 1);
});
assert(check.success());

check = typecheck(() => {
  let k = (a: num, b: num) => a + b;
  k(1, "a");
});
assert(check.failure());

// param constrains the function body.

let g: string -> string;
let h: num -> num;

check = typecheck((a: num) => h(a));
assert(check.success());

check = typecheck((a: num) => g(a));
assert(check.failure());

// multiple params constrain the function body.

check = typecheck(
  (a: num, b: num) => {
    h(a);
    h(b);
  }
);
assert(check.success());

check = typecheck(
  (a: num, b: num) => {
    h(a);
    g(b);
  }
);
assert(check.failure());

// homographic local in adjacent scope.

check = typecheck(() => {
  let k = (a: num) => h(a);
  let j = (a: string) => g(a);
});
assert(check.success());

check = typecheck(() => {
  let k = (a: num) => h(a);
  let j = (a: string) => h(a);
});
assert(check.failure());

check = typecheck(() => {
  let k = (a: num) => g(a);
  let j = (a: string) => g(a);
});
assert(check.failure());

// fn declarations constrained against their signatures.
// --------------------------------------------
// check = typecheck(() => {
//   let g: string = (a) => a;
// });
// assert(check.failure());

// inference.
// --------------------------------------------

let h;
let hType;
let principal;

// fn from num.

check = typecheck(() => h(1));

principal = check.principal();
hType = principal.find((n) => n.data == "h");

assert(hType is TFunction);
assert(hType.domain is TNumber);
assert(hType.range is TVar);

// fn from bool.

check = typecheck(() => h(true));

principal = check.principal();
hType = principal.find((n) => n.data == "h");

assert(hType is TFunction);
assert(hType.domain is TBoolean);
assert(hType.range is TVar);

// fn from string.

check = typecheck(() => h("a"));

principal = check.principal();
hType = principal.find((n) => n.data == "h");

assert(hType is TFunction);
assert(hType.domain is TString);
assert(hType.range is TVar);