let seq;

// literal body.

seq = [true | a in [1,2,3]];
assert(seq == [true,true,true]);

// variable body.

seq = [a | a in [1,2,3]];
assert(seq == [1,2,3]);

// expression body.

seq = [(a + 1) | a in [1,2,3]];
assert(seq == [2,3,4]);

// multiple iterable conditions.

// cartesian product of a and b.
seq = [[a, b] | a in [1,2,3], b in [3,2,1]];

// predicative condition.

seq = [a | a in [1,2,3], a != 3];
assert(seq == [1,2]);

seq = [a | a in [1,2,3], a != 3, a != 2];
assert(seq == [1]);

// vacuous condition.

seq = [a | a in [1,2,3], true];
assert(seq == [1,2,3]);

seq = [a | a in [1,2,3], false];
assert(seq == []);

// nested iterable conditions.

seq = [a | a in b, b in [[1,2],[3,4],[5,6]]];
assert(seq == [1,2,3,4,5,6]);

seq = [a + c | a in b, b in [[1,2],[3,4]], c in [9,8,7]];
assert(seq == [
  // 1,2,3,4,
  // 1,2,3,4,
  // 1,2,3,4,
  // 1,2,3,4,
]);

seq = [[a, b] | a in c, b in c, c in [[1,2],[3,4]]];
assert(seq == [
  [1,1],
  [1,2],
  [2,1],
  [2,2],
  [3,3],
  [3,4],
  [4,3],
  [4,4]
]);

seq = [[b, c] | b in a, a in [[1,2],[3,4]], c in [9,8,7]];
assert(seq == []);

// nested iterable bodies.

seq = [[true | b in a] | a in [[1,2],[3], [4,5]]];
assert(seq == [
  [true,true],
  [true],
  [true, true]
]);

seq = [a + b | a in [1,2,3], a != 3, b in [1,2,3]];
assert(seq == [
  2,3,4,
  3,4,5
]);