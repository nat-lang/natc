
// constant function to literal.

let f <- (a) => 1;

assert(f.name == "lambda");
assert(f.signature is ASTSignature);
assert(vType(f.function) == OClosure);

// explicit and implicit returns.
assert(len(f.children) == 2);

// explicit.
assert(f[0] is ASTReturn);
assert(f[0][0] is ASTLiteral);
assert(f[0][0].value == 1);

// implicit.
assert(f[1] is ASTImplicitReturn);
assert(f[1][0] is ASTLiteral);
assert(f[1][0].value == nil);

// negation.

let f <- (a) => !a;

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTNegation);
assert(f[0][0][0] is ASTLocal);

// constant function to global.
f <- (a) => c;

// explicit and implicit returns.
assert(len(f.children) == 2);

// explicit.
assert(f[0] is ASTReturn);
assert(f[0][0] is ASTGlobal);
assert(f[0][0].id == "c");

// implicit.
assert(f[1] is ASTImplicitReturn);
assert(f[1][0] is ASTLiteral);
assert(f[1][0].value == nil);

// constant function to local.
f <- (a) => a;

// explicit and implicit returns.
assert(len(f.children) == 2);

// explicit.
assert(f[0] is ASTReturn);
assert(f[0][0] is ASTLocal);
assert(f[0][0].id == 1);

// implicit.
assert(f[1] is ASTImplicitReturn);
assert(f[1][0] is ASTLiteral);
assert(f[1][0].value == nil);

// function to infix.

f <- (a) => a + 1;

let r = f[0];

assert(r is ASTReturn);
assert(r[0] is ASTApp);
assert(r[0][0].id == "+");

f <- (a) => +(a, 1);

let r = f[0];
assert(r is ASTReturn);
assert(r[0] is ASTApp);
assert(r[0][0].id == "+");

f <- (a) => a and true;

let r = f[0];
assert(r is ASTReturn);
assert(r[0] is ASTApp);
assert(r[0][0].id == "and");

f <- (a) => a or true;

let r = f[0];
assert(r is ASTReturn);
assert(r[0] is ASTApp);
assert(r[0][0].id == "or");

f <- (a) => a implies b;

let r = f[0];
assert(r is ASTReturn);
assert(r[0] is ASTApp);
assert(r[0][0].id == "implies");

// function to postfix.

f <- (a) => [1,2,3];

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTApp);
assert(f[0][0][0].id == "Sequence");
assert(f[0][0][1].resolve() == [1,2,3]);

// function to function.

f <- (g) => (x) => 1;

assert(f[0][0] is ASTClosure);
assert(f[0][0][0][0] is ASTLiteral);

f <- (g) => (x) => g(x);

assert(f[0][0] is ASTClosure);
assert(f[0][0][0][0] is ASTApp);

f <- (f, g) => (x) => f(g(x));

assert(f[0][0] is ASTClosure);
assert(f[0][0][0][0] is ASTApp);

// local assignment.

f <- (g) => {
  let a = 1;
  return a;
};

assert(len(f.children) == 4);

assert(f[0] is ASTLocalTypeAssignment);
assert(f[1] is ASTLocalValueAssignment);
assert(f[1][1] is ASTLiteral);
assert(f[2] is ASTReturn);
assert(f[3] is ASTImplicitReturn);

f <- (g) => {
  let k = (x) => 1;
  k(1);
};

assert(len(f.children) == 4);

assert(f[0] is ASTLocalTypeAssignment);
assert(f[1] is ASTLocalValueAssignment);
assert(f[1][1] is ASTClosure);
assert(f[2] is ASTExprStatement);
assert(f[3] is ASTImplicitReturn);

f <- (g) => {
  let k = (x) => 1;
  let j = 1;
  k(j);
};

assert(len(f.children) == 6);
// k.
assert(f[0] is ASTLocalTypeAssignment);
assert(f[1] is ASTLocalValueAssignment);
assert(f[1][1] is ASTClosure);
// j.
assert(f[2] is ASTLocalTypeAssignment);
assert(f[3] is ASTLocalValueAssignment);
assert(f[3][1] is ASTLiteral);
// k(j).
assert(f[4] is ASTExprStatement);
assert(f[5] is ASTImplicitReturn);

// closures.

f <- (x,z) => {
  let y;
  
  let g = () => x + z;
  let h = () => x + y;
  let j = () => {
    let a;
    return () => x + y + a;
  };
};

// upvalues are identified with the locals
// they close over.

f.uniquelyIdentifyVariables(x => {});

let x = f.signature.params[0];
let z = f.signature.params[1];
let y = f[1][0];

let g = f[3][1];
let h = f[5][1];
let j = f[7][1];

let g_x_up = g[0][0][1][0];
let g_z_up = g[0][0][1][1];

assert(g_x_up.uuid == x.uuid);
assert(g_z_up.uuid == z.uuid);

let h_x_up = h[0][0][1][0];
let h_y_up = h[0][0][1][1];

assert(h_x_up.uuid == x.uuid);
assert(h_y_up.uuid == y.uuid);

let a = j[1][0];
let j_x_up = j[2][0][0][0][1][0][1][0];
let j_y_up = j[2][0][0][0][1][0][1][1];
let j_a_up = j[2][0][0][0][1][1];

assert(j_x_up.uuid == x.uuid);
assert(j_y_up.uuid == y.uuid);
assert(j_a_up.uuid == a.uuid);

// invocation.

class A {}
let a = A();

f <- () => a.f();

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTInvocation);
assert(f[0][0][0].resolve() is A);
assert(f[0][0][1] == "f");
assert(f[0][0][2].leaf());

f <- () => a.f(1,2,3);

assert(f[0] is ASTReturn);
assert(f[0][0] is ASTInvocation);
assert(f[0][0][0].resolve() is A);
assert(f[0][0][1] == "f");
assert(f[0][0][2].resolve() == [1,2,3]);

// resolution, aka evaluation.

// obj language.

f <- (g) => {
  let k = 1 + 1;
};

assert(f[1][1] is ASTApp);
assert(f[1][1].resolve() == 2);

// type language.

f <- () => {
  let k = (a: num -> num) => a(1);
};

assert(f[1][1] is ASTClosure);

let closure = f[1][1];
let param = closure.signature.params[0];

assert(param is ASTParameter);
assert(param.type.resolve() is TFunction);

